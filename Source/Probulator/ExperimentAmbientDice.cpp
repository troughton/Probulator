#include <iostream>
#include <fstream>

#include "ExperimentAmbientDice.h"

#include <Eigen/Eigen>
#include <Eigen/nnls.h>

#include "ExperimentAmbientD20.h"
#include "MicrosurfaceScattering.h"

#include <chrono>

static const bool useHemisphereVertexPositions = false;
static const size_t vertexCount = 12;

namespace Probulator {
    
    const float80 AmbientDice::kT = 0.61803398874989484820458683436563811772030917980576286213;
    const float80 AmbientDice::kT2 = kT * kT;
    
    const vec3 AmbientDice::vertexPositions[12] = {
        vec3(1.0, kT, 0.0),
        vec3(-1.0, kT, 0.0),
        vec3(1.0, -kT, -0.0),
        vec3(-1.0, -kT, 0.0),
        vec3(0.0, 1.0, kT),
        vec3(-0.0, -1.0, kT),
        vec3(0.0, 1.0, -kT),
        vec3(0.0, -1.0, -kT),
        vec3(kT, 0.0, 1.0),
        vec3(-kT, 0.0, 1.0),
        vec3(kT, -0.0, -1.0),
        vec3(-kT, -0.0, -1.0)
    };
    
    const vec3 AmbientDice::srbfNormalisedVertexPositions[6] = {
        normalize(vec3(1.0, kT, 0.0)),
        normalize(vec3(-1.0, kT, 0.0)),
        normalize(vec3(0.0, 1.0, kT)),
        normalize(vec3(-0.0, -1.0, kT)),
        normalize(vec3(kT, 0.0, 1.0)),
        normalize(vec3(kT, -0.0, -1.0))
    };
    
    const vec3 AmbientDice::srbfHemisphereVertexPositions[9] = {
        vec3(0.5257311121191337, -0.30353099910334314, 0.7946544722917661),
        vec3(0.0, 0.6070619982066864, 0.7946544722917661),
        vec3(-0.5257311121191337, -0.30353099910334314, 0.7946544722917661),
        vec3(0.8506508083520399, 0.49112347318842303, 0.18759247408507987),
        vec3(-0.8506508083520399, 0.49112347318842303, 0.18759247408507987),
        vec3(0.0, -0.982246946376846, 0.1875924740850799),
        vec3(-0.8506508083520399, -0.49112347318842303, -0.18759247408507987),
        vec3(0.8506508083520399, -0.49112347318842303, -0.18759247408507987),
        vec3(0.0, 0.982246946376846, -0.1875924740850799)
    };
    
    //    const vec3 AmbientDice::srbfHemisphereVertexPositions[9] = {
    //        sampleVogelsSphere(0, 18), // vec3(-0.8506508083520399, -0.49112347318842303, -0.18759247408507987),
    //        sampleVogelsSphere(1, 18), // vec3(0.0, -0.982246946376846, 0.1875924740850799),
    //        sampleVogelsSphere(2, 18), // vec3(0.0, 0.982246946376846, -0.1875924740850799),
    //        sampleVogelsSphere(3, 18), // vec3(0.5257311121191337, -0.30353099910334314, 0.7946544722917661),
    //        sampleVogelsSphere(4, 18), // vec3(0.0, 0.6070619982066864, 0.7946544722917661),
    //        sampleVogelsSphere(5, 18), // vec3(-0.5257311121191337, -0.30353099910334314, 0.7946544722917661),
    //        sampleVogelsSphere(6, 18), // vec3(0.8506508083520399, -0.49112347318842303, -0.18759247408507987),
    //        sampleVogelsSphere(7, 18), // vec3(0.8506508083520399, 0.49112347318842303, 0.18759247408507987),
    //        sampleVogelsSphere(8, 18), // vec3(-0.8506508083520399, 0.49112347318842303, 0.18759247408507987)
    //    };
    
    
    const vec3 AmbientDice::tangents[12] = {
        vec3(0.27639312, -0.44721365, -0.85065085),
        vec3(0.27639312, 0.44721365, 0.85065085),
        vec3(0.27639312, 0.44721365, 0.85065085),
        vec3(0.27639312, -0.44721365, 0.85065085),
        vec3(1.0, -0.0, -0.0),
        vec3(1.0, -0.0, 0.0),
        vec3(1.0, -0.0, 0.0),
        vec3(1.0, 0.0, 0.0),
        vec3(0.8506508, -0.0, -0.52573115),
        vec3(0.8506508, 0.0, 0.52573115),
        vec3(0.8506508, 0.0, 0.52573115),
        vec3(0.8506508, -0.0, -0.52573115)
        
        //        vec3(-0.52573115, 0.85065085, 0.0),
        //        vec3(-0.52573115, -0.85065085, 0.0),
        //        vec3(0.52573115, 0.85065085, 0.0),
        //        vec3(0.52573115, -0.85065085, 0.0),
        //        vec3(-0.99999994, 0.0, 0.0),
        //        vec3(0.99999994, -0.0, 0.0),
        //        vec3(-0.99999994, 0.0, 0.0),
        //        vec3(0.99999994, 0.0, 0.0),
        //        vec3(-0.0, 1.0, 0.0),
        //        vec3(-0.0, -1.0, 0.0),
        //        vec3(0.0, 1.0, 0.0),
        //        vec3(0.0, -1.0, 0.0),
    };
    
    const vec3 AmbientDice::bitangents[12] = {
        vec3(-0.44721365, 0.72360677, -0.52573115),
        vec3(0.44721365, 0.72360677, -0.52573115),
        vec3(-0.44721365, -0.72360677, 0.52573115),
        vec3(-0.44721365, 0.72360677, 0.52573115),
        vec3(-0.0, 0.525731, -0.85065085),
        vec3(-0.0, 0.525731, 0.85065085),
        vec3(0.0, -0.525731, -0.85065085),
        vec3(-0.0, -0.525731, 0.85065085),
        vec3(-0.0, 1.0, -0.0),
        vec3(0.0, 1.0, -0.0),
        vec3(-0.0, -1.0, 0.0),
        vec3(0.0, -1.0, 0.0)
        
        //        vec3(0.0, -0.0, 1.0),
        //        vec3(0.0, 0.0, 1.0),
        //        vec3(0.0, -0.0, 1.0),
        //        vec3(0.0, 0.0, 1.0),
        //        vec3(0.0, -0.52573115, 0.85065085),
        //        vec3(0.0, 0.52573115, 0.85065085),
        //        vec3(0.0, 0.52573115, 0.85065085),
        //        vec3(0.0, -0.52573115, 0.85065085),
        //        vec3(-0.8506507, -0.0, 0.5257311),
        //        vec3(0.8506507, 0.0, 0.5257311),
        //        vec3(0.8506507, -0.0, 0.5257311),
        //        vec3(-0.8506507, 0.0, 0.5257311),
    };
    
    const u32 AmbientDice::triangleIndices[20][3] = {
        { 0, 4, 8 },
        { 1, 4, 9 },
        { 2, 5, 8 },
        { 3, 5, 9 },
        { 0, 6, 10 },
        { 1, 6, 11 },
        { 2, 7, 10 },
        { 3, 7, 11 },
        { 4, 8, 9 },
        { 5, 8, 9 },
        { 6, 10, 11 },
        { 7, 10, 11 },
        { 0, 2, 8 },
        { 1, 3, 9 },
        { 0, 2, 10 },
        { 1, 3, 11 },
        { 0, 4, 6 },
        { 1, 4, 6 },
        { 2, 5, 7 },
        { 3, 5, 7 },
    };
    const vec3 AmbientDice::triangleBarycentricNormals[20][3] = {
        { vec3(0.9510565, 0.36327127, -0.58778524), vec3(-0.58778524, 0.9510565, 0.36327127), vec3(0.36327127, -0.58778524, 0.9510565) },
        { vec3(-0.9510565, 0.36327127, -0.58778524), vec3(0.58778524, 0.9510565, 0.36327127), vec3(-0.36327127, -0.58778524, 0.9510565) },
        { vec3(0.9510565, -0.36327127, -0.58778524), vec3(-0.58778524, -0.9510565, 0.36327127), vec3(0.36327127, 0.58778524, 0.9510565) },
        { vec3(-0.9510565, -0.36327127, -0.58778524), vec3(0.58778524, -0.9510565, 0.36327127), vec3(-0.36327127, 0.58778524, 0.9510565) },
        { vec3(0.9510565, 0.36327127, 0.58778524), vec3(-0.58778524, 0.9510565, -0.36327127), vec3(0.36327127, -0.58778524, -0.9510565) },
        { vec3(-0.9510565, 0.36327127, 0.58778524), vec3(0.58778524, 0.9510565, -0.36327127), vec3(-0.36327127, -0.58778524, -0.9510565) },
        { vec3(0.9510565, -0.36327127, 0.58778524), vec3(-0.58778524, -0.9510565, -0.36327127), vec3(0.36327127, 0.58778524, -0.9510565) },
        { vec3(-0.9510565, -0.36327127, 0.58778524), vec3(0.58778524, -0.9510565, -0.36327127), vec3(-0.36327127, 0.58778524, -0.9510565) },
        { vec3(-0.0, 1.1755705, -0.0), vec3(0.9510565, -0.36327127, 0.58778524), vec3(-0.9510565, -0.36327127, 0.58778524) },
        { vec3(0.0, -1.1755705, 0.0), vec3(0.9510565, 0.36327127, 0.58778524), vec3(-0.9510565, 0.36327127, 0.58778524) },
        { vec3(0.0, 1.1755705, -0.0), vec3(0.9510565, -0.36327127, -0.58778524), vec3(-0.9510565, -0.36327127, -0.58778524) },
        { vec3(-0.0, -1.1755705, 0.0), vec3(0.9510565, 0.36327127, -0.58778524), vec3(-0.9510565, 0.36327127, -0.58778524) },
        { vec3(0.58778524, 0.9510565, -0.36327127), vec3(0.58778524, -0.9510565, -0.36327127), vec3(-0.0, -0.0, 1.1755705) },
        { vec3(-0.58778524, 0.9510565, -0.36327127), vec3(-0.58778524, -0.9510565, -0.36327127), vec3(0.0, 0.0, 1.1755705) },
        { vec3(0.58778524, 0.9510565, 0.36327127), vec3(0.58778524, -0.9510565, 0.36327127), vec3(0.0, 0.0, -1.1755705) },
        { vec3(-0.58778524, 0.9510565, 0.36327127), vec3(-0.58778524, -0.9510565, 0.36327127), vec3(-0.0, -0.0, -1.1755705) },
        { vec3(1.1755705, -0.0, -0.0), vec3(-0.36327127, 0.58778524, 0.9510565), vec3(-0.36327127, 0.58778524, -0.9510565) },
        { vec3(-1.1755705, 0.0, 0.0), vec3(0.36327127, 0.58778524, 0.9510565), vec3(0.36327127, 0.58778524, -0.9510565) },
        { vec3(1.1755705, 0.0, 0.0), vec3(-0.36327127, -0.58778524, 0.9510565), vec3(-0.36327127, -0.58778524, -0.9510565) },
        { vec3(-1.1755705, -0.0, -0.0), vec3(0.36327127, -0.58778524, 0.9510565), vec3(0.36327127, -0.58778524, -0.9510565) },
    };
    
    const float AmbientDice::triDerivativeTangentFactors[20][6] = {
        { -0.34100485f, -0.238272f, 0.3504874f, 0.21661313f, 0.2981424f, -0.11388027f },
        { 0.34100485f, 0.238272f, -0.3504874f, -0.21661313f, -0.2981424f, 0.11388027f },
        { 0.027519437f, 0.35801283f, 0.3504874f, 0.21661313f, 0.2981424f, -0.11388027f },
        { 0.34100485f, 0.238272f, -0.3504874f, -0.21661313f, -0.2981424f, 0.11388027f },
        { 0.027519437f, 0.35801283f, 0.3504874f, 0.21661313f, 0.2981424f, -0.11388027f },
        { -0.027519437f, -0.35801283f, -0.3504874f, -0.21661313f, -0.2981424f, 0.11388027f },
        { -0.34100485f, -0.238272f, 0.3504874f, 0.21661313f, 0.2981424f, -0.11388027f },
        { -0.027519437f, -0.35801283f, -0.3504874f, -0.21661313f, -0.2981424f, 0.11388027f },
        { 0.21661313f, -0.21661313f, -0.11388027f, -0.36852428f, 0.11388027f, 0.36852428f },
        { 0.21661313f, -0.21661313f, -0.11388027f, -0.36852428f, 0.11388027f, 0.36852428f },
        { 0.21661313f, -0.21661313f, -0.11388027f, -0.36852428f, 0.11388027f, 0.36852428f },
        { 0.21661313f, -0.21661313f, -0.11388027f, -0.36852428f, 0.11388027f, 0.36852428f },
        { 0.1937447f, -0.238272f, 0.1937447f, 0.35801283f, 0.2981424f, 0.2981424f },
        { -0.1937447f, 0.238272f, -0.1937447f, 0.238272f, -0.2981424f, -0.2981424f },
        { 0.1937447f, 0.35801283f, 0.1937447f, -0.238272f, 0.2981424f, 0.2981424f },
        { -0.1937447f, -0.35801283f, -0.1937447f, -0.35801283f, -0.2981424f, -0.2981424f },
        { -0.34100485f, 0.027519437f, 0.3504874f, 0.0f, 0.3504874f, 0.0f },
        { 0.34100485f, -0.027519437f, -0.3504874f, 0.0f, -0.3504874f, 0.0f },
        { 0.027519437f, -0.34100485f, 0.3504874f, 0.0f, 0.3504874f, 0.0f },
        { 0.34100485f, -0.027519437f, -0.3504874f, 0.0f, -0.3504874f, 0.0f }
    };
    const float AmbientDice::triDerivativeBitangentFactors[20][6] = {
        { 0.1397348f, -0.2811345f, 0.11388027f, -0.2981424f, 0.21661313f, 0.3504874f },
        { 0.1397348f, -0.2811345f, 0.11388027f, -0.2981424f, 0.21661313f, 0.3504874f },
        { 0.36749536f, 0.08738982f, -0.11388027f, 0.2981424f, -0.21661313f, -0.3504874f },
        { -0.1397348f, 0.2811345f, -0.11388027f, 0.2981424f, -0.21661313f, -0.3504874f },
        { 0.36749536f, 0.08738982f, -0.11388027f, 0.2981424f, -0.21661313f, -0.3504874f },
        { 0.36749536f, 0.08738982f, -0.11388027f, 0.2981424f, -0.21661313f, -0.3504874f },
        { 0.1397348f, -0.2811345f, 0.11388027f, -0.2981424f, 0.21661313f, 0.3504874f },
        { -0.36749536f, -0.08738982f, 0.11388027f, -0.2981424f, 0.21661313f, 0.3504874f },
        { -0.2981424f, -0.2981424f, 0.3504874f, 0.0f, 0.3504874f, 0.0f },
        { 0.2981424f, 0.2981424f, -0.3504874f, 0.0f, -0.3504874f, 0.0f },
        { 0.2981424f, 0.2981424f, -0.3504874f, 0.0f, -0.3504874f, 0.0f },
        { -0.2981424f, -0.2981424f, 0.3504874f, 0.0f, 0.3504874f, 0.0f },
        { -0.31348547f, -0.2811345f, -0.31348547f, 0.08738982f, 0.21661313f, -0.21661313f },
        { -0.31348547f, -0.2811345f, 0.31348547f, 0.2811345f, 0.21661313f, -0.21661313f },
        { -0.31348547f, 0.08738982f, -0.31348547f, -0.2811345f, -0.21661313f, 0.21661313f },
        { -0.31348547f, 0.08738982f, 0.31348547f, -0.08738982f, -0.21661313f, 0.21661313f },
        { 0.1397348f, 0.36749536f, 0.11388027f, 0.36852428f, -0.11388027f, -0.36852428f },
        { 0.1397348f, 0.36749536f, 0.11388027f, 0.36852428f, -0.11388027f, -0.36852428f },
        { 0.36749536f, 0.1397348f, -0.11388027f, -0.36852428f, 0.11388027f, 0.36852428f },
        { -0.1397348f, -0.36749536f, -0.11388027f, -0.36852428f, 0.11388027f, 0.36852428f }
    };
    
    const double AmbientDice::gramMatrixBezier[36][36] = {
        { 0.591709, -1.70158e-08, 8.35533e-08, 0, 0, 0, 0.0747991, 0.0178657, -0.0289073, 0, 0, 0, 0.0747988, 0.0323192, 0.0105012, 0, 0, 0, 0.0747987, 0.0323191, -0.0105011, 0, 0, 0, 0.074799, 0.0274924, 0.0199745, 0, 0, 0, 0.0747991, 0.0274924, -0.0199744, 0, 0, 0, },
        { -1.70158e-08, 0.0389574, -3.19622e-08, 0, 0, 0, 0.0178657, 0.00123648, -0.0081224, 0, 0, 0, -0.0314448, -0.0130972, -0.00274716, 0, 0, 0, 0.00253763, 0.00218706, 0.00325638, 0, 0, 0, -0.0219717, -0.00582474, -0.00779951, 0, 0, 0, 0.0330133, 0.0118283, -0.00748472, 0, 0, 0, },
        { 8.35533e-08, -3.19622e-08, 0.0389574, 0, 0, 0, -0.0289073, -0.0081224, 0.0093589, 0, 0, 0, 0.0128853, 0.00410339, 0.00501432, 0, 0, 0, 0.0338875, 0.0135495, -0.0046996, 0, 0, 0, -0.025924, -0.010312, -0.00446844, 0, 0, 0, 0.00805843, 0.000598114, -0.00497774, 0, 0, 0, },
        { 0, 0, 0, 0.591709, 5.35355e-08, 8.20932e-08, 0, 0, 0, 0.074799, -0.0178657, 0.0289073, 0.0747987, -0.0323191, 0.0105011, 0, 0, 0, 0.0747988, -0.0323192, -0.0105012, 0, 0, 0, 0, 0, 0, 0.0747991, -0.0274924, 0.0199744, 0, 0, 0, 0.074799, -0.0274924, -0.0199745, },
        { 0, 0, 0, 5.35355e-08, 0.0389573, 2.12357e-08, 0, 0, 0, -0.0178657, 0.00671193, -0.0047384, 0.0314448, -0.0130972, 0.00274715, 0, 0, 0, -0.0025376, 0.00218704, -0.00325638, 0, 0, 0, 0, 0, 0, 0.0219716, -0.00582473, 0.0077995, 0, 0, 0, -0.0330131, 0.0118282, 0.00748474, },
        { 0, 0, 0, 8.20932e-08, 2.12357e-08, 0.0389574, 0, 0, 0, -0.0289072, 0.00473839, -0.0114503, 0.0128852, -0.00410338, 0.00501432, 0, 0, 0, 0.0338876, -0.0135495, -0.00469961, 0, 0, 0, 0, 0, 0, -0.0259241, 0.010312, -0.00446843, 0, 0, 0, 0.0080585, -0.000598139, -0.00497775, },
        { 0.0747991, 0.0178657, -0.0289073, 0, 0, 0, 0.591709, -1.54771e-08, 8.38016e-08, 0, 0, 0, 0, 0, 0, 0.0747987, 0.0323191, -0.0105011, 0, 0, 0, 0.0747988, 0.0323192, 0.0105012, 0.0747991, 0.0274924, -0.0199744, 0, 0, 0, 0.074799, 0.0274924, 0.0199745, 0, 0, 0, },
        { 0.0178657, 0.00123648, -0.0081224, 0, 0, 0, -1.54771e-08, 0.0389574, -3.15809e-08, 0, 0, 0, 0, 0, 0, 0.00253763, 0.00218706, 0.00325638, 0, 0, 0, -0.0314448, -0.0130971, -0.00274716, 0.0330133, 0.0118283, -0.00748472, 0, 0, 0, -0.0219717, -0.00582474, -0.00779951, 0, 0, 0, },
        { -0.0289073, -0.0081224, 0.0093589, 0, 0, 0, 8.38016e-08, -3.15809e-08, 0.0389574, 0, 0, 0, 0, 0, 0, 0.0338875, 0.0135495, -0.0046996, 0, 0, 0, 0.0128853, 0.00410339, 0.00501432, 0.00805842, 0.000598114, -0.00497774, 0, 0, 0, -0.025924, -0.010312, -0.00446844, 0, 0, 0, },
        { 0, 0, 0, 0.074799, -0.0178657, -0.0289072, 0, 0, 0, 0.591709, 2.12892e-08, -9.19825e-08, 0, 0, 0, 0.0747988, -0.0323192, -0.0105012, 0, 0, 0, 0.0747987, -0.0323191, 0.0105011, 0, 0, 0, 0.074799, -0.0274924, -0.0199745, 0, 0, 0, 0.0747991, -0.0274924, 0.0199744, },
        { 0, 0, 0, -0.0178657, 0.00671193, 0.00473839, 0, 0, 0, 2.12892e-08, 0.0389574, -2.91868e-08, 0, 0, 0, 0.0314448, -0.0130972, -0.00274716, 0, 0, 0, -0.00253763, 0.00218706, 0.00325638, 0, 0, 0, 0.0219717, -0.00582474, -0.00779951, 0, 0, 0, -0.0330133, 0.0118283, -0.00748472, },
        { 0, 0, 0, 0.0289073, -0.0047384, -0.0114503, 0, 0, 0, -9.19825e-08, -2.91868e-08, 0.0389574, 0, 0, 0, -0.0128853, 0.00410339, 0.00501432, 0, 0, 0, -0.0338875, 0.0135495, -0.0046996, 0, 0, 0, 0.025924, -0.010312, -0.00446844, 0, 0, 0, -0.00805843, 0.000598114, -0.00497774, },
        { 0.0747988, -0.0314448, 0.0128853, 0.0747987, 0.0314448, 0.0128852, 0, 0, 0, 0, 0, 0, 0.591709, 5.47219e-09, 7.24456e-08, 0, 0, 0, 0.0747988, -5.29109e-09, -0.0339824, 0, 0, 0, 0.074799, -0.0105013, 0.0323193, 0.0747991, 0.0105012, 0.0323193, 0, 0, 0, 0, 0, 0, },
        { 0.0323192, -0.0130972, 0.00410339, -0.0323191, -0.0130972, -0.00410338, 0, 0, 0, 0, 0, 0, 5.47219e-09, 0.0389574, -2.67962e-09, 0, 0, 0, 4.07076e-09, 0.00378339, -9.7413e-10, 0, 0, 0, 0.0199743, 0.000299328, 0.00898386, -0.0199744, 0.000299349, -0.00898387, 0, 0, 0, 0, 0, 0, },
        { 0.0105012, -0.00274716, 0.00501432, 0.0105011, 0.00274715, 0.00501432, 0, 0, 0, 0, 0, 0, 7.24456e-08, -2.67962e-09, 0.0389574, 0, 0, 0, 0.0339824, -1.50768e-09, -0.0143788, 0, 0, 0, -0.0274925, 0.00570977, -0.0103761, -0.0274925, -0.00570977, -0.0103761, 0, 0, 0, 0, 0, 0, },
        { 0, 0, 0, 0, 0, 0, 0.0747987, 0.00253763, 0.0338875, 0.0747988, 0.0314448, -0.0128853, 0, 0, 0, 0.591709, -9.8812e-09, -7.6907e-08, 0, 0, 0, 0.0747988, 4.7105e-09, 0.0339824, 0.0747991, -0.0105012, -0.0323193, 0.074799, 0.0105013, -0.0323193, 0, 0, 0, 0, 0, 0, },
        { 0, 0, 0, 0, 0, 0, 0.0323191, 0.00218706, 0.0135495, -0.0323192, -0.0130972, 0.00410339, 0, 0, 0, -9.8812e-09, 0.0389574, -2.37552e-09, 0, 0, 0, -4.59195e-09, 0.00378339, -1.18189e-09, 0.0199744, 0.000299349, -0.00898387, -0.0199743, 0.000299328, 0.00898386, 0, 0, 0, 0, 0, 0, },
        { 0, 0, 0, 0, 0, 0, -0.0105011, 0.00325638, -0.0046996, -0.0105012, -0.00274716, 0.00501432, 0, 0, 0, -7.6907e-08, -2.37552e-09, 0.0389574, 0, 0, 0, -0.0339824, -1.34707e-09, -0.0143788, 0.0274925, -0.00570977, -0.0103761, 0.0274925, 0.00570977, -0.0103761, 0, 0, 0, 0, 0, 0, },
        { 0.0747987, 0.00253763, 0.0338875, 0.0747988, -0.0025376, 0.0338876, 0, 0, 0, 0, 0, 0, 0.0747988, 4.07076e-09, 0.0339824, 0, 0, 0, 0.591709, -1.37871e-08, -7.15453e-08, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0747991, -0.0105012, -0.0323193, 0.074799, 0.0105013, -0.0323193, },
        { 0.0323191, 0.00218706, 0.0135495, -0.0323192, 0.00218704, -0.0135495, 0, 0, 0, 0, 0, 0, -5.29109e-09, 0.00378339, -1.50768e-09, 0, 0, 0, -1.37871e-08, 0.0389574, -2.42242e-09, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0199744, 0.000299349, -0.00898387, -0.0199743, 0.000299328, 0.00898386, },
        { -0.0105011, 0.00325638, -0.0046996, -0.0105012, -0.00325638, -0.00469961, 0, 0, 0, 0, 0, 0, -0.0339824, -9.7413e-10, -0.0143788, 0, 0, 0, -7.15453e-08, -2.42242e-09, 0.0389574, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0274925, -0.00570977, -0.0103761, 0.0274925, 0.00570977, -0.0103761, },
        { 0, 0, 0, 0, 0, 0, 0.0747988, -0.0314448, 0.0128853, 0.0747987, -0.00253763, -0.0338875, 0, 0, 0, 0.0747988, -4.59195e-09, -0.0339824, 0, 0, 0, 0.591709, 1.09827e-08, 7.52977e-08, 0, 0, 0, 0, 0, 0, 0.074799, -0.0105013, 0.0323193, 0.0747991, 0.0105012, 0.0323193, },
        { 0, 0, 0, 0, 0, 0, 0.0323192, -0.0130971, 0.00410339, -0.0323191, 0.00218706, 0.0135495, 0, 0, 0, 4.7105e-09, 0.00378339, -1.34707e-09, 0, 0, 0, 1.09827e-08, 0.0389574, -2.45215e-09, 0, 0, 0, 0, 0, 0, 0.0199743, 0.000299328, 0.00898386, -0.0199744, 0.000299349, -0.00898387, },
        { 0, 0, 0, 0, 0, 0, 0.0105012, -0.00274716, 0.00501432, 0.0105011, 0.00325638, -0.0046996, 0, 0, 0, 0.0339824, -1.18189e-09, -0.0143788, 0, 0, 0, 7.52977e-08, -2.45215e-09, 0.0389574, 0, 0, 0, 0, 0, 0, -0.0274925, 0.00570977, -0.0103761, -0.0274925, -0.00570977, -0.0103761, },
        { 0.074799, -0.0219717, -0.025924, 0, 0, 0, 0.0747991, 0.0330133, 0.00805842, 0, 0, 0, 0.074799, 0.0199743, -0.0274925, 0.0747991, 0.0199744, 0.0274925, 0, 0, 0, 0, 0, 0, 0.591744, -1.7741e-05, 3.51106e-07, 0.0748425, 0.0340023, 3.01532e-07, 0, 0, 0, 0, 0, 0, },
        { 0.0274924, -0.00582474, -0.010312, 0, 0, 0, 0.0274924, 0.0118283, 0.000598114, 0, 0, 0, -0.0105013, 0.000299328, 0.00570977, -0.0105012, 0.000299349, -0.00570977, 0, 0, 0, 0, 0, 0, -1.7741e-05, 0.0389661, -1.27422e-07, -0.0340038, -0.0143885, -1.37941e-07, 0, 0, 0, 0, 0, 0, },
        { 0.0199745, -0.00779951, -0.00446844, 0, 0, 0, -0.0199744, -0.00748472, -0.00497774, 0, 0, 0, 0.0323193, 0.00898386, -0.0103761, -0.0323193, -0.00898387, -0.0103761, 0, 0, 0, 0, 0, 0, 3.51106e-07, -1.27422e-07, 0.0389575, 3.05637e-07, 1.49163e-07, 0.00378353, 0, 0, 0, 0, 0, 0, },
        { 0, 0, 0, 0.0747991, 0.0219716, -0.0259241, 0, 0, 0, 0.074799, 0.0219717, 0.025924, 0.0747991, -0.0199744, -0.0274925, 0.074799, -0.0199743, 0.0274925, 0, 0, 0, 0, 0, 0, 0.0748425, -0.0340038, 3.05637e-07, 0.591758, 2.27911e-05, 2.53957e-07, 0, 0, 0, 0, 0, 0, },
        { 0, 0, 0, -0.0274924, -0.00582473, 0.010312, 0, 0, 0, -0.0274924, -0.00582474, -0.010312, 0.0105012, 0.000299349, -0.00570977, 0.0105013, 0.000299328, 0.00570977, 0, 0, 0, 0, 0, 0, 0.0340023, -0.0143885, 1.49163e-07, 2.27911e-05, 0.0389678, 1.58954e-07, 0, 0, 0, 0, 0, 0, },
        { 0, 0, 0, 0.0199744, 0.0077995, -0.00446843, 0, 0, 0, -0.0199745, -0.00779951, -0.00446844, 0.0323193, -0.00898387, -0.0103761, -0.0323193, 0.00898386, -0.0103761, 0, 0, 0, 0, 0, 0, 3.01532e-07, -1.37941e-07, 0.00378353, 2.53957e-07, 1.58954e-07, 0.0389575, 0, 0, 0, 0, 0, 0, },
        { 0.0747991, 0.0330133, 0.00805843, 0, 0, 0, 0.074799, -0.0219717, -0.025924, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0747991, 0.0199744, 0.0274925, 0.074799, 0.0199743, -0.0274925, 0, 0, 0, 0, 0, 0, 0.591661, 2.19453e-05, 5.28521e-07, 0.0747558, 0.0339617, 4.61022e-07, },
        { 0.0274924, 0.0118283, 0.000598114, 0, 0, 0, 0.0274924, -0.00582474, -0.010312, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.0105012, 0.000299349, -0.00570977, -0.0105013, 0.000299328, 0.00570977, 0, 0, 0, 0, 0, 0, 2.19453e-05, 0.0389472, -2.08718e-07, -0.0339625, -0.0143692, -2.10188e-07, },
        { -0.0199744, -0.00748472, -0.00497774, 0, 0, 0, 0.0199745, -0.00779951, -0.00446844, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.0323193, -0.00898387, -0.0103761, 0.0323193, 0.00898386, -0.0103761, 0, 0, 0, 0, 0, 0, 5.28521e-07, -2.08718e-07, 0.0389575, 4.58088e-07, 2.24171e-07, 0.00378353, },
        { 0, 0, 0, 0.074799, -0.0330131, 0.0080585, 0, 0, 0, 0.0747991, -0.0330133, -0.00805843, 0, 0, 0, 0, 0, 0, 0.074799, -0.0199743, 0.0274925, 0.0747991, -0.0199744, -0.0274925, 0, 0, 0, 0, 0, 0, 0.0747558, -0.0339625, 4.58088e-07, 0.591668, -1.94045e-05, 3.81176e-07, },
        { 0, 0, 0, -0.0274924, 0.0118282, -0.000598139, 0, 0, 0, -0.0274924, 0.0118283, 0.000598114, 0, 0, 0, 0, 0, 0, 0.0105013, 0.000299328, 0.00570977, 0.0105012, 0.000299349, -0.00570977, 0, 0, 0, 0, 0, 0, 0.0339617, -0.0143692, 2.24171e-07, -1.94045e-05, 0.038948, 2.2463e-07, },
        { 0, 0, 0, -0.0199745, 0.00748474, -0.00497775, 0, 0, 0, 0.0199744, -0.00748472, -0.00497774, 0, 0, 0, 0, 0, 0, -0.0323193, 0.00898386, -0.0103761, 0.0323193, -0.00898387, -0.0103761, 0, 0, 0, 0, 0, 0, 4.61022e-07, -2.10188e-07, 0.00378353, 3.81176e-07, 2.2463e-07, 0.0389575, },
    };
    
    const double AmbientDice::gramMatrixSRBF[12][12] = {
        { 0.354651, 0, 0.00790714, 0.130602, 0.130602, 0.00790713, 0.00790713, 0.130602, 0.130602, 0.00790712, 0.130602, 0.00790712, },
        { 0, 0.354651, 0.130602, 0.00790714, 0.00790714, 0.130602, 0.130602, 0.00790714, 0.00790713, 0.130602, 0.00790713, 0.130602, },
        { 0.00790714, 0.130602, 0.354651, 0, 0.130602, 0.00790714, 0.00790714, 0.130602, 0.00790713, 0.130602, 0.00790713, 0.130602, },
        { 0.130602, 0.00790714, 0, 0.354651, 0.00790713, 0.130602, 0.130602, 0.00790713, 0.130602, 0.00790712, 0.130602, 0.00790712, },
        { 0.130602, 0.00790714, 0.130602, 0.00790713, 0.354654, 0, 0.00790971, 0.130602, 0.130611, 0.00790713, 0.00790714, 0.130611, },
        { 0.00790713, 0.130602, 0.00790714, 0.130602, 0, 0.354649, 0.130602, 0.00790456, 0.00790714, 0.130594, 0.130594, 0.00790713, },
        { 0.00790713, 0.130602, 0.00790714, 0.130602, 0.00790971, 0.130602, 0.354654, 0, 0.13061, 0.00790714, 0.00790713, 0.130611, },
        { 0.130602, 0.00790714, 0.130602, 0.00790713, 0.130602, 0.00790456, 0, 0.354648, 0.00790713, 0.130594, 0.130593, 0.00790714, },
        { 0.130602, 0.00790713, 0.00790713, 0.130602, 0.130611, 0.00790714, 0.13061, 0.00790713, 0.354677, 0, 0.00790714, 0.130631, },
        { 0.00790712, 0.130602, 0.130602, 0.00790712, 0.00790713, 0.130594, 0.00790714, 0.130594, 0, 0.354624, 0.130574, 0.00790714, },
        { 0.130602, 0.00790713, 0.00790713, 0.130602, 0.00790714, 0.130594, 0.00790713, 0.130593, 0.00790714, 0.130574, 0.354621, 0, },
        { 0.00790712, 0.130602, 0.130602, 0.00790712, 0.130611, 0.00790713, 0.130611, 0.00790714, 0.130631, 0.00790714, 0, 0.354682, },
    };
    
    inline void constructOrthonormalBasis(vec3 n, vec3 *b1, vec3 *b2) {
        float sign = copysign(1.0f, n.z);
        const float a = -1.0f / (sign + n.z);
        const float b = n.x * n.y * a;
        *b1 = vec3(1.0f + sign * n.x * n.x * a, sign * b, -sign * n.x);
        *b2 = vec3(b, sign + n.y * n.y * a, -n.y);
    }
    
    template <typename T>
    void AmbientDice::hybridCubicBezierWeights(u32 triIndex, float b0, float b1, float b2, VertexWeights<T> *w0Out, VertexWeights<T> *w1Out, VertexWeights<T> *w2Out) {
        const T alpha = 0.5f * sqrt(0.5 * (5.0f + sqrt(5.0f))); // 0.9510565163
        const T beta = -0.5f * sqrt(0.1 * (5.0f + sqrt(5.0f))); // -0.4253254042
        
        const T a0 = (sqrt(5.0) - 5.0) / 40.0; // -0.06909830056
        const T a1 = (11.0f * sqrt(5.0) - 15.0) / 40.0; // 0.2399186938
        const T a2 = sqrt(5.0) / 10.0; // 0.2236067977
        
        const T fValueFactor = -beta / alpha; // 0.4472135955
        
        const T weightDenom = b1 * b2 + b0 * b2 + b0 * b1;
        
        T w0 = (b1 * b2) / weightDenom;
        T w1 = (b0 * b2) / weightDenom;
        T w2 = (b0 * b1) / weightDenom;
        
        if (b0 == 1.0) {
            w0 = 1.0;
            w1 = 0.0;
            w2 = 0.0;
        } else if (b1 == 1.0) {
            w0 = 0.0;
            w1 = 1.0;
            w2 = 0.0;
        } else if (b2 == 1.0) {
            w0 = 0.0;
            w1 = 0.0;
            w2 = 1.0;
        }
        
        // https://en.wikipedia.org/wiki/Bézier_triangle
        // Notation: cxyz means alpha^x, beta^y, gamma^z.
        
        T v0ValueWeight = 0.0;
        T v1ValueWeight = 0.0;
        T v2ValueWeight = 0.0;
        
        T v0DUWeight = 0.0;
        T v1DUWeight = 0.0;
        T v2DUWeight = 0.0;
        
        T v0DVWeight = 0.0;
        T v1DVWeight = 0.0;
        T v2DVWeight = 0.0;
        
        const T b0_2 = b0 * b0;
        const T b1_2 = b1 * b1;
        const T b2_2 = b2 * b2;
        
        // Add c300, c030, and c003
        T c300Weight = b0_2 * b0;
        T c030Weight = b1_2 * b1;
        T c003Weight = b2_2 * b2;
        
        T c120Weight = 3 * b0 * b1_2;
        T c021Weight = 3 * b1_2 * b2;
        T c210Weight = 3 * b0_2 * b1;
        T c012Weight = 3 * b1 * b2_2;
        T c201Weight = 3 * b0_2 * b2;
        T c102Weight = 3 * b0 * b2_2;
        
        const T c111Weight = 6 * b0 * b1 * b2;
        const T c0_111Weight = w0 * c111Weight;
        const T c1_111Weight = w1 * c111Weight;
        const T c2_111Weight = w2 * c111Weight;
        
        v1ValueWeight += a0 * c0_111Weight;
        v2ValueWeight += a0 * c1_111Weight;
        v0ValueWeight += a0 * c2_111Weight;
        
        c021Weight += a1 * c0_111Weight;
        c012Weight += a1 * c0_111Weight;
        c003Weight += a0 * c0_111Weight;
        c120Weight += a2 * c0_111Weight;
        c102Weight += a2 * c0_111Weight;
        
        c102Weight += a1 * c1_111Weight;
        c201Weight += a1 * c1_111Weight;
        c300Weight += a0 * c1_111Weight;
        c012Weight += a2 * c1_111Weight;
        c210Weight += a2 * c1_111Weight;
        
        c210Weight += a1 * c2_111Weight;
        c120Weight += a1 * c2_111Weight;
        c030Weight += a0 * c2_111Weight;
        c201Weight += a2 * c2_111Weight;
        c021Weight += a2 * c2_111Weight;
        
        v0ValueWeight += fValueFactor * c210Weight;
        v0DUWeight += AmbientDice::triDerivativeTangentFactors[triIndex][0] * c210Weight;
        v0DVWeight += AmbientDice::triDerivativeBitangentFactors[triIndex][0] * c210Weight;
        
        v0ValueWeight += fValueFactor * c201Weight;
        v0DUWeight += AmbientDice::triDerivativeTangentFactors[triIndex][1] * c201Weight;
        v0DVWeight += AmbientDice::triDerivativeBitangentFactors[triIndex][1] * c201Weight;
        
        v1ValueWeight += fValueFactor * c120Weight;
        v1DUWeight += AmbientDice::triDerivativeTangentFactors[triIndex][2] * c120Weight;
        v1DVWeight += AmbientDice::triDerivativeBitangentFactors[triIndex][2] * c120Weight;
        
        v1ValueWeight += fValueFactor * c021Weight;
        v1DUWeight += AmbientDice::triDerivativeTangentFactors[triIndex][3] * c021Weight;
        v1DVWeight += AmbientDice::triDerivativeBitangentFactors[triIndex][3] * c021Weight;
        
        v2ValueWeight += fValueFactor * c102Weight;
        v2DUWeight += AmbientDice::triDerivativeTangentFactors[triIndex][4] * c102Weight;
        v2DVWeight += AmbientDice::triDerivativeBitangentFactors[triIndex][4] * c102Weight;
        
        v2ValueWeight += fValueFactor * c012Weight;
        v2DUWeight += AmbientDice::triDerivativeTangentFactors[triIndex][5] * c012Weight;
        v2DVWeight += AmbientDice::triDerivativeBitangentFactors[triIndex][5] * c012Weight;
        
        v0ValueWeight += c300Weight;
        v1ValueWeight += c030Weight;
        v2ValueWeight += c003Weight;
        
        *w0Out = { v0ValueWeight, v0DUWeight, v0DVWeight };
        *w1Out = { v1ValueWeight, v1DUWeight, v1DVWeight };
        *w2Out = { v2ValueWeight, v2DUWeight, v2DVWeight };
    }
    
    //    void AmbientDice::hybridCubicBezierWeights(u32 i0, u32 i1, u32 i2, float b0, float b1, float b2, VertexWeights *w0Out, VertexWeights *w1Out, VertexWeights *w2Out) const {
    //        const float alpha = 0.5f * sqrt(0.5f * (5.0f + sqrt(5.0f))); // 0.9510565163
    //        const float beta = -0.5f * sqrt(0.1f * (5.0f + sqrt(5.0f))); // -0.4253254042
    //
    //        const float a0 = (sqrt(5.0f) - 5.0f) / 40.0f; // -0.06909830056
    //        const float a1 = (11.0f * sqrt(5.0f) - 15.0f) / 40.0f; // 0.2399186938
    //        const float a2 = sqrt(5.0f) / 10.0f; // 0.2236067977
    //
    //        // Project the edges onto the sphere.
    //        // This amounts to a no-op since the edge vectors are already tangent to the sphere.
    //        vec3 v0V1 = AmbientDice::vertexPositions[i1] - AmbientDice::vertexPositions[i0];
    //        vec3 v1V0 = -v0V1;
    //        vec3 v0V2 = AmbientDice::vertexPositions[i2] - AmbientDice::vertexPositions[i0];
    //        vec3 v2V0 = -v0V2;
    //        vec3 v1V2 = AmbientDice::vertexPositions[i2] - AmbientDice::vertexPositions[i1];
    //        vec3 v2V1 = -v1V2;
    //
    //
    //        const float fValueFactor = -beta / alpha; // 0.4472135955
    //        const float fDerivativeFactor = 1.0 / (3.0 * alpha); // 0.3504874081
    //
    //        const float weightDenom = b1 * b2 + b0 * b2 + b0 * b1;
    //
    //        float w0 = (b1 * b2) / weightDenom;
    //        float w1 = (b0 * b2) / weightDenom;
    //        float w2 = (b0 * b1) / weightDenom;
    //
    //        if (b0 == 1.0) {
    //            w0 = 1.0;
    //            w1 = 0.0;
    //            w2 = 0.0;
    //        } else if (b1 == 1.0) {
    //            w0 = 0.0;
    //            w1 = 1.0;
    //            w2 = 0.0;
    //        } else if (b2 == 1.0) {
    //            w0 = 0.0;
    //            w1 = 0.0;
    //            w2 = 1.0;
    //        }
    //
    //        // https://en.wikipedia.org/wiki/Bézier_triangle
    //        // Notation: cxyz means alpha^x, beta^y, gamma^z.
    //
    //        float v0ValueWeight = 0.0;
    //        float v1ValueWeight = 0.0;
    //        float v2ValueWeight = 0.0;
    //
    //        float v0DUWeight = 0.0;
    //        float v1DUWeight = 0.0;
    //        float v2DUWeight = 0.0;
    //
    //        float v0DVWeight = 0.0;
    //        float v1DVWeight = 0.0;
    //        float v2DVWeight = 0.0;
    //
    //        const float b0_2 = b0 * b0;
    //        const float b1_2 = b1 * b1;
    //        const float b2_2 = b2 * b2;
    //
    //        // Add c300, c030, and c003
    //        float c300Weight = b0_2 * b0;
    //        float c030Weight = b1_2 * b1;
    //        float c003Weight = b2_2 * b2;
    //
    //        float c120Weight = 3 * b0 * b1_2;
    //        float c021Weight = 3 * b1_2 * b2;
    //        float c210Weight = 3 * b0_2 * b1;
    //        float c012Weight = 3 * b1 * b2_2;
    //        float c201Weight = 3 * b0_2 * b2;
    //        float c102Weight = 3 * b0 * b2_2;
    //
    //        const float c111Weight = 6 * b0 * b1 * b2;
    //        const float c0_111Weight = w0 * c111Weight;
    //        const float c1_111Weight = w1 * c111Weight;
    //        const float c2_111Weight = w2 * c111Weight;
    //
    //        v1ValueWeight += a0 * c0_111Weight;
    //        v2ValueWeight += a0 * c1_111Weight;
    //        v0ValueWeight += a0 * c2_111Weight;
    //
    //        c021Weight += a1 * c0_111Weight;
    //        c012Weight += a1 * c0_111Weight;
    //        c003Weight += a0 * c0_111Weight;
    //        c120Weight += a2 * c0_111Weight;
    //        c102Weight += a2 * c0_111Weight;
    //
    //        c102Weight += a1 * c1_111Weight;
    //        c201Weight += a1 * c1_111Weight;
    //        c300Weight += a0 * c1_111Weight;
    //        c012Weight += a2 * c1_111Weight;
    //        c210Weight += a2 * c1_111Weight;
    //
    //        c210Weight += a1 * c2_111Weight;
    //        c120Weight += a1 * c2_111Weight;
    //        c030Weight += a0 * c2_111Weight;
    //        c201Weight += a2 * c2_111Weight;
    //        c021Weight += a2 * c2_111Weight;
    //
    //
    //        v0ValueWeight += fValueFactor * c210Weight;
    //        v0DUWeight += fDerivativeFactor * dot(v0V1, AmbientDice::tangents[i0]) * c210Weight;
    //        v0DVWeight += fDerivativeFactor * dot(v0V1, AmbientDice::bitangents[i0]) * c210Weight;
    //
    //        float dot0 = dot(v0V1, AmbientDice::tangents[i0]);
    //        float dot1 = dot(v0V1, AmbientDice::bitangents[i0]);
    //
    //        v0ValueWeight += fValueFactor * c201Weight;
    //        v0DUWeight += fDerivativeFactor * dot(v0V2, AmbientDice::tangents[i0]) * c201Weight;
    //        v0DVWeight += fDerivativeFactor * dot(v0V2, AmbientDice::bitangents[i0]) * c201Weight;
    //
    //        float dot2 = dot(v0V2, AmbientDice::tangents[i0]);
    //        float dot3 = dot(v0V2, AmbientDice::bitangents[i0]);
    //
    //        v1ValueWeight += fValueFactor * c120Weight;
    //        v1DUWeight += fDerivativeFactor * dot(v1V0, AmbientDice::tangents[i1]) * c120Weight;
    //        v1DVWeight += fDerivativeFactor * dot(v1V0, AmbientDice::bitangents[i1]) * c120Weight;
    //
    //        float dot4 = dot(v1V0, AmbientDice::tangents[i1]);
    //        float dot5 = dot(v1V0, AmbientDice::bitangents[i1]);
    //
    //        v1ValueWeight += fValueFactor * c021Weight;
    //        v1DUWeight += fDerivativeFactor * dot(v1V2, AmbientDice::tangents[i1]) * c021Weight;
    //        v1DVWeight += fDerivativeFactor * dot(v1V2, AmbientDice::bitangents[i1]) * c021Weight;
    //
    //        float dot6 = dot(v1V2, AmbientDice::tangents[i1]);
    //        float dot7 = dot(v1V2, AmbientDice::bitangents[i1]);
    //
    //        v2ValueWeight += fValueFactor * c102Weight;
    //        v2DUWeight += fDerivativeFactor * dot(v2V0, AmbientDice::tangents[i2]) * c102Weight;
    //        v2DVWeight += fDerivativeFactor * dot(v2V0, AmbientDice::bitangents[i2]) * c102Weight;
    //
    //        float dot8 = dot(v2V0, AmbientDice::tangents[i2]);
    //        float dot9 = dot(v2V0, AmbientDice::bitangents[i2]);
    //
    //        v2ValueWeight += fValueFactor * c012Weight;
    //        v2DUWeight += fDerivativeFactor * dot(v2V1, AmbientDice::tangents[i2]) * c012Weight;
    //        v2DVWeight += fDerivativeFactor * dot(v2V1, AmbientDice::bitangents[i2]) * c012Weight;
    //
    //        float dot10 = dot(v2V1, AmbientDice::tangents[i2]);
    //        float dot11 = dot(v2V1, AmbientDice::bitangents[i2]);
    //
    //        printf("Dot Products: %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f\n", dot0, dot1, dot2, dot3, dot4, dot5, dot6, dot7, dot8, dot9, dot10, dot11);
    //
    //        v0ValueWeight += c300Weight;
    //        v1ValueWeight += c030Weight;
    //        v2ValueWeight += c003Weight;
    //
    //        *w0Out = { v0ValueWeight, v0DUWeight, v0DVWeight };
    //        *w1Out = { v1ValueWeight, v1DUWeight, v1DVWeight };
    //        *w2Out = { v2ValueWeight, v2DUWeight, v2DVWeight };
    //    }
    
    template<typename T>
    void AmbientDice::hybridCubicBezierWeights(vec3 direction, u32 *i0Out, u32 *i1Out, u32 *i2Out, VertexWeights<T> *w0Out, VertexWeights<T> *w1Out, VertexWeights<T> *w2Out) {
        
        u32 triIndex, i0, i1, i2;
        float b0, b1, b2;
        AmbientDice::computeBarycentrics(direction, &triIndex, &i0, &i1, &i2, &b0, &b1, &b2);
        
        AmbientDice::hybridCubicBezierWeights(triIndex, b0, b1, b2, w0Out, w1Out, w2Out);
        
        *i0Out = i0;
        *i1Out = i1;
        *i2Out = i2;
    }
    
    template<typename T>
    void AmbientDice::srbfWeights(vec3 direction, T *weightsOut) {
        if (useHemisphereVertexPositions) {
            for (u64 i = 0; i < 9; i += 1) {
                float dotProduct = max(dot(direction, AmbientDice::srbfHemisphereVertexPositions[i]), 0.f);
                
                T cos2 = dotProduct * dotProduct;
                T cos4 = cos2 * cos2;
                
                weightsOut[i] = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
            }
            for (u64 i = 9; i < 12; i += 1) {
                weightsOut[i] = 0.f;
            }
        } else {
            for (u64 i = 0; i < 6; i += 1) {
                float dotProduct = dot(direction, AmbientDice::srbfNormalisedVertexPositions[i]);
                u32 index = dotProduct > 0 ? (2 * i) : (2 * i + 1);
                
                T cos2 = dotProduct * dotProduct;
                T cos4 = cos2 * cos2;
                
                weightsOut[index] = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
            }
        }
    }
    
    vec3 AmbientDice::evaluateSRBF(const vec3& direction) const
    {
        vec3 result = vec3(0.f);
        if (useHemisphereVertexPositions) {
            for (u64 i = 0; i < 9; i += 1) {
                float dotProduct = max(dot(direction, AmbientDice::srbfHemisphereVertexPositions[i]), 0.f);
                
                float cos2 = dotProduct * dotProduct;
                float cos4 = cos2 * cos2;
                
                float weight = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
                
                //            float weight = 0.6f * exp(3.1f * (dotProduct - 1.f));
                result += weight * this->vertices[i].value;
            }
        } else {
            for (u64 i = 0; i < 6; i += 1) {
                float dotProduct = dot(direction, AmbientDice::srbfNormalisedVertexPositions[i]);
                u32 index = dotProduct > 0 ? (2 * i) : (2 * i + 1);
                
                float cos2 = dotProduct * dotProduct;
                float cos4 = cos2 * cos2;
                
                float weight = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
                
                //            float weight = 0.6f * exp(3.1f * (dotProduct - 1.f));
                result += weight * this->vertices[index].value;
            }
        }
        
        return result;
    }
    
    AmbientDice ExperimentAmbientDice::solveAmbientDiceRunningAverageBezier(const ImageBase<vec3>& directions, const Image& irradiance)
    {
        AmbientDice ambientDice;
        AmbientDice::VertexWeights<float> vertexWeights[12] = { { 0.f, 0.f, 0.f } };
        
        const u64 sampleCount = directions.getPixelCount();
        
        std::vector<u64> sampleIndices;
        sampleIndices.resize(sampleCount);
        std::iota(sampleIndices.begin(), sampleIndices.end(), 0);
        
        std::random_shuffle(sampleIndices.begin(), sampleIndices.end());
        
        float sampleIndex = 0.f;
        for (u64 sampleIt : sampleIndices)
        {
            sampleIndex += 1;
            
            const vec3& direction = directions.at(sampleIt);
            
            u32 i0, i1, i2;
            AmbientDice::VertexWeights<float> weights[3];
            AmbientDice::hybridCubicBezierWeights(direction, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
            
            const u32 indices[3] = { i0, i1, i2 };
            
            // What's the current value in the sample's direction?
            vec4 targetValue = irradiance.at(sampleIt);
            vec3 currentEstimate =
            weights[0].value * ambientDice.vertices[i0].value +
            weights[0].directionalDerivativeU * ambientDice.vertices[i0].directionalDerivativeU +
            weights[0].directionalDerivativeV * ambientDice.vertices[i0].directionalDerivativeV +
            weights[1].value * ambientDice.vertices[i1].value +
            weights[1].directionalDerivativeU * ambientDice.vertices[i1].directionalDerivativeU +
            weights[1].directionalDerivativeV * ambientDice.vertices[i1].directionalDerivativeV +
            weights[2].value * ambientDice.vertices[i2].value +
            weights[2].directionalDerivativeU * ambientDice.vertices[i2].directionalDerivativeU +
            weights[2].directionalDerivativeV * ambientDice.vertices[i2].directionalDerivativeV;
            
            vec3 delta = vec3(targetValue.x, targetValue.y, targetValue.z) - currentEstimate;
            
            const float sampleWeightScale = 1.f / sampleIndex;
            
            const float alpha = 3.0f;
            const bool gaussSeidel = false;
            
            for (u64 i = 0; i < 3; i += 1) {
                u32 index = indices[i];
                const AmbientDice::VertexWeights<float> &weight = weights[i];
                
                vertexWeights[index].value += (weight.value * weight.value - vertexWeights[index].value) * sampleWeightScale;
                vertexWeights[index].directionalDerivativeU += (weight.directionalDerivativeU * weight.directionalDerivativeU - vertexWeights[index].directionalDerivativeU) * sampleWeightScale;
                vertexWeights[index].directionalDerivativeV += (weight.directionalDerivativeV * weight.directionalDerivativeV - vertexWeights[index].directionalDerivativeV) * sampleWeightScale;
                
                {
                    float sphericalIntegral = sampleWeightScale + (1 - sampleWeightScale) * vertexWeights[index].value;
                    
                    float deltaScale = alpha * weights[i].value * sampleWeightScale / sphericalIntegral;
                    ambientDice.vertices[index].value += delta * deltaScale;
                    
                    if (gaussSeidel) {
                        delta *= 1.0f - deltaScale * vertexWeights[index].value;
                    }
                }
                
                {
                    float sphericalIntegral = sampleWeightScale + (1 - sampleWeightScale) * vertexWeights[index].directionalDerivativeU;
                    
                    float deltaScale = alpha * weights[i].directionalDerivativeU * sampleWeightScale / sphericalIntegral;
                    ambientDice.vertices[index].directionalDerivativeU += delta * deltaScale;
                    
                    if (gaussSeidel) {
                        delta *= 1.0f - deltaScale * vertexWeights[index].value;
                    }
                }
                
                {
                    float sphericalIntegral = sampleWeightScale + (1 - sampleWeightScale) * vertexWeights[index].directionalDerivativeV;
                    
                    float deltaScale = alpha * weights[i].directionalDerivativeV * sampleWeightScale / sphericalIntegral;
                    ambientDice.vertices[index].directionalDerivativeV += delta * deltaScale;
                    
                    if (gaussSeidel) {
                        delta *= 1.0f - deltaScale * vertexWeights[index].value;
                    }
                }
                
                if (false /* nonNegative */) {
                    ambientDice.vertices[index].value = max(ambientDice.vertices[index].value, vec3(0.f));
                    ambientDice.vertices[index].directionalDerivativeU = max(ambientDice.vertices[index].directionalDerivativeU, vec3(0.f));
                    ambientDice.vertices[index].directionalDerivativeV = max(ambientDice.vertices[index].directionalDerivativeV, vec3(0.f));
                }
            }
            
            for (u64 index = 0; index < 12; index += 1) {
                if (index == i0 || index == i1 || index == i2) continue;
                vertexWeights[index].value *= (1.f - sampleWeightScale);
            }
        }
        
        return ambientDice;
    }
    
    AmbientDice ExperimentAmbientDice::solveAmbientDiceRunningAverageSRBF(const ImageBase<vec3>& directions, const Image& irradiance)
    {
        AmbientDice ambientDice;
        AmbientDice::VertexWeights<float> vertexWeights[12] = { { 0.f, 0.f, 0.f } };
        
        const u64 sampleCount = directions.getPixelCount();
        
        std::vector<u64> sampleIndices;
        sampleIndices.resize(sampleCount);
        std::iota(sampleIndices.begin(), sampleIndices.end(), 0);
        
        std::random_shuffle(sampleIndices.begin(), sampleIndices.end());
        
        float sampleIndex = 0.f;
        for (u64 sampleIt : sampleIndices)
        {
            sampleIndex += 1;
            
            const vec3& direction = directions.at(sampleIt);
            
            float weights[12] = { 0.f };
            AmbientDice::srbfWeights(direction, weights);
            
            // What's the current value in the sample's direction?
            vec4 targetValue = irradiance.at(sampleIt);
            vec3 currentEstimate = ambientDice.evaluateSRBF(direction);
            
            const vec3 delta = vec3(targetValue.x, targetValue.y, targetValue.z) - currentEstimate;
            
            const float sampleWeightScale = 1.f / sampleIndex;
            
            const float alpha = 3.0f;
            
            for (u64 i = 0; i < 12; i += 1) {
                float weight = weights[i];
                
                vertexWeights[i].value += (weight * weight - vertexWeights[i].value) * sampleWeightScale;
                
                float sphericalIntegral = sampleWeightScale + (1 - sampleWeightScale) * vertexWeights[i].value;
                
                float deltaScale = alpha * weight * sampleWeightScale / sphericalIntegral;
                ambientDice.vertices[i].value += delta * deltaScale;
                
                if (false /* nonNegative */) {
                    ambientDice.vertices[i].value = max(ambientDice.vertices[i].value, vec3(0.f));
                }
            }
        }
        
        return ambientDice;
    }
    
    
    template<typename _Matrix_Type_>
    _Matrix_Type_ pseudoInverse( const _Matrix_Type_ &a, double epsilon = std::numeric_limits<double>::epsilon() )
    {
        return a.inverse();
        //        Eigen::JacobiSVD< _Matrix_Type_ > svd( a, Eigen::ComputeThinU | Eigen::ComputeThinV );
        //        double tolerance = epsilon * std::max( a.cols(), a.rows() ) *svd.singularValues().array().abs()( 0 );
        //        return svd.matrixV() *  ( svd.singularValues().array().abs() > tolerance ).select( svd.singularValues().array().inverse(), 0 ).matrix().asDiagonal() * svd.matrixU().adjoint();
    }
    
    Eigen::MatrixXd computeCosineGramMatrixBezier(bool hemispherical) {
        using namespace Eigen;
        
        const u64 sampleCount = 16384;
        double sampleScale = (hemispherical ? 2 * M_PI : 4 * M_PI) / double(sampleCount);
        
        const u64 brdfSampleCount = 16384;
        double brdfSampleScale = 1.f / double(brdfSampleCount);
        
        MatrixXd gram = MatrixXd::Zero(36, 36);
        
        for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
            vec2 sample = sampleHammersley(sampleIt, sampleCount);
            vec3 direction = hemispherical ? sampleUniformHemisphere(sample.x, sample.y) : sampleUniformSphere(sample);
            mat3 tangentToWorld = makeOrthogonalBasis(direction);
            
            double bWeights[36] = { 0.f };
            
            u32 i0, i1, i2;
            AmbientDice::VertexWeights<double> weights[3];
            AmbientDice::hybridCubicBezierWeights(direction, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
            
            bWeights[3 * i0 + 0] = weights[0].value;
            bWeights[3 * i0 + 1] = weights[0].directionalDerivativeU;
            bWeights[3 * i0 + 2] = weights[0].directionalDerivativeV;
            
            bWeights[3 * i1 + 0] = weights[1].value;
            bWeights[3 * i1 + 1] = weights[1].directionalDerivativeU;
            bWeights[3 * i1 + 2] = weights[1].directionalDerivativeV;
            
            bWeights[3 * i2 + 0] = weights[2].value;
            bWeights[3 * i2 + 1] = weights[2].directionalDerivativeU;
            bWeights[3 * i2 + 2] = weights[2].directionalDerivativeV;
            
            double aWeights[36] = { 0.f };
            
            for (u64 brdfSampleIt = 0; brdfSampleIt < brdfSampleCount; brdfSampleIt += 1) {
                vec3 brdfTangentDirection = sampleCosineHemisphere(sampleHammersley(brdfSampleIt, brdfSampleCount));
                vec3 brdfWorldDirection = tangentToWorld * brdfTangentDirection;
                
                AmbientDice::hybridCubicBezierWeights(brdfWorldDirection, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
                
                aWeights[3 * i0 + 0] += brdfSampleScale * weights[0].value;
                aWeights[3 * i0 + 1] += brdfSampleScale * weights[0].directionalDerivativeU;
                aWeights[3 * i0 + 2] += brdfSampleScale * weights[0].directionalDerivativeV;
                
                aWeights[3 * i1 + 0] += brdfSampleScale * weights[1].value;
                aWeights[3 * i1 + 1] += brdfSampleScale * weights[1].directionalDerivativeU;
                aWeights[3 * i1 + 2] += brdfSampleScale * weights[1].directionalDerivativeV;
                
                aWeights[3 * i2 + 0] += brdfSampleScale * weights[2].value;
                aWeights[3 * i2 + 1] += brdfSampleScale * weights[2].directionalDerivativeU;
                aWeights[3 * i2 + 2] += brdfSampleScale * weights[2].directionalDerivativeV;
            }
            
            for (u64 lobeAIt = 0; lobeAIt < 36; ++lobeAIt)
            {
                for (u64 lobeBIt = lobeAIt; lobeBIt < 36; ++lobeBIt)
                {
                    double delta = aWeights[lobeAIt] * bWeights[lobeBIt] * sampleScale;
                    gram(lobeAIt, lobeBIt) += delta;
                    
                    if (lobeBIt != lobeAIt) {
                        gram(lobeBIt, lobeAIt) += delta;
                    }
                }
            }
            
        }
        
        return gram;
    }
    
    Eigen::MatrixXd computeCosineGramMatrixSRBF(bool hemispherical) {
        using namespace Eigen;
        
        const u64 sampleCount = 16384;
        double sampleScale = (hemispherical ? (2 * M_PI) : (4 * M_PI)) / double(sampleCount);
        
        const u64 brdfSampleCount = 16384;
        double brdfSampleScale = 1.f / double(brdfSampleCount);
        
        MatrixXd gram = MatrixXd::Zero(vertexCount, vertexCount);
        
        for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
            vec2 sample = sampleHammersley(sampleIt, sampleCount);
            vec3 direction = hemispherical ? sampleUniformHemisphere(sample.x, sample.y) : sampleUniformSphere(sample);
            mat3 tangentToWorld = makeOrthogonalBasis(direction);
            
            float bWeights[12] = { 0.f };
            AmbientDice::srbfWeights(direction, bWeights);
            
            double aWeights[12] = { 0.f };
            
            for (u64 brdfSampleIt = 0; brdfSampleIt < brdfSampleCount; brdfSampleIt += 1) {
                vec3 brdfTangentDirection = sampleCosineHemisphere(sampleHammersley(brdfSampleIt, brdfSampleCount));
                vec3 brdfWorldDirection = tangentToWorld * brdfTangentDirection;
                if (hemispherical && brdfWorldDirection.z < 0.f) {
                    continue;
                }
                
                float aWeightsLocal[12] = { 0.f };
                
                AmbientDice::srbfWeights(brdfWorldDirection, aWeightsLocal);
                
                for (u64 i = 0; i < 12; i += 1) {
                    aWeights[i] += aWeightsLocal[i] * brdfSampleScale;
                }
            }
            
            for (u64 lobeAIt = 0; lobeAIt < vertexCount; ++lobeAIt)
            {
                for (u64 lobeBIt = lobeAIt; lobeBIt < vertexCount; ++lobeBIt)
                {
                    double delta = aWeights[lobeAIt] * bWeights[lobeBIt] * sampleScale;
                    gram(lobeAIt, lobeBIt) += delta;
                    
                    if (lobeBIt != lobeAIt) {
                        gram(lobeBIt, lobeAIt) += delta;
                    }
                }
            }
            
        }
        
        //        {
        //            double vertexCoverageScales[9] = { 0.0 };
        //            double vertexCoverageScalesSphere[9] = { 0.0 };
        //
        //            for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
        //                vec2 sample = sampleHammersley(sampleIt, sampleCount);
        //                vec3 direction = sampleUniformHemisphere(sample.x, sample.y);
        //                vec3 sphereDirection = sampleUniformSphere(sample);
        //
        //                mat3 tangentToWorld = makeOrthogonalBasis(direction);
        //                mat3 tangentToWorldSphere = makeOrthogonalBasis(sphereDirection);
        //
        //                double aWeights[12] = { 0.f };
        //                double aWeightsSphere[12] = { 0.f };
        //
        //                for (u64 brdfSampleIt = 0; brdfSampleIt < brdfSampleCount; brdfSampleIt += 1) {
        //                    vec3 brdfTangentDirection = sampleCosineHemisphere(sampleHammersley(brdfSampleIt, brdfSampleCount));
        //                    vec3 brdfWorldDirection = tangentToWorld * brdfTangentDirection;
        //                    vec3 brdfWorldDirectionSphere = tangentToWorldSphere * brdfTangentDirection;
        //
        //                    if (hemispherical && brdfWorldDirection.z >= 0.f) {
        //                        float aWeightsLocal[12] = { 0.f };
        //
        //                        AmbientDice::srbfWeights(brdfWorldDirection, aWeightsLocal);
        //
        //                        for (u64 i = 0; i < 12; i += 1) {
        //                            aWeights[i] += aWeightsLocal[i] * brdfSampleScale;
        //                        }
        //                    }
        //
        //
        //                    float aWeightsLocal[12] = { 0.f };
        //
        //                    AmbientDice::srbfWeights(brdfWorldDirectionSphere, aWeightsLocal);
        //                    for (u64 i = 0; i < 12; i += 1) {
        //                        aWeightsSphere[i] += aWeightsLocal[i] * brdfSampleScale;
        //                    }
        //
        //                }
        //
        //                for (u64 lobeAIt = 0; lobeAIt < vertexCount; ++lobeAIt)
        //                {
        //                    double delta = aWeights[lobeAIt] * sampleScale;
        //                    vertexCoverageScales[lobeAIt] += delta;
        //                    vertexCoverageScalesSphere[lobeAIt] += aWeightsSphere[lobeAIt] * sampleScale;
        //                }
        //
        //            }
        //
        //            std::cout << "Vertex coverage scales: \n";
        //            for (int i = 0; i < 9; i += 1) {
        //                std::cout << vertexCoverageScales[i] / vertexCoverageScalesSphere[i] << ", ";
        //            }
        //            std::cout << "\n";
        //        }
        
        if (false) {
            double vertexCoverageScales[9] = { 0.0 };
            
            const u64 sampleCount = 1024;
            double sampleScale = (hemispherical ? (2 * M_PI) : (4 * M_PI)) / double(sampleCount);
            
            for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
                vec2 sample = sampleHammersley(sampleIt, sampleCount);
                vec3 direction = sampleUniformHemisphere(sample.x, sample.y);
                
                mat3 tangentToWorld = makeOrthogonalBasis(direction);
                
                double aWeights[12] = { 0.f };
                
                for (u64 brdfSampleIt = 0; brdfSampleIt < brdfSampleCount; brdfSampleIt += 1) {
                    vec3 brdfTangentDirection = sampleCosineHemisphere(sampleHammersley(brdfSampleIt, brdfSampleCount));
                    vec3 brdfWorldDirection = tangentToWorld * brdfTangentDirection;
                    
                    if (brdfWorldDirection.z >= 0.f) {
                        float aWeightsLocal[9] = { 0.f };
                        for (u64 i = 0; i < 9; i += 1) {
                            float dotProduct = max(dot(brdfWorldDirection, AmbientDice::srbfHemisphereVertexPositions[i]), 0.f);
                            
                            float cos2 = dotProduct * dotProduct;
                            float cos4 = cos2 * cos2;
                            
                            aWeightsLocal[i] = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
                        }
                        
                        for (u64 i = 0; i < 9; i += 1) {
                            aWeights[i] += aWeightsLocal[i] * brdfSampleScale;
                        }
                    }
                }
                
                for (u64 i = 0; i < 9; i += 1) {
                    if (AmbientDice::srbfHemisphereVertexPositions[i].z > 0.f) { continue; }
                    double dotProduct = dot(AmbientDice::srbfHemisphereVertexPositions[i], direction);
                    double fittedWeight = 0.06f + 0.129 * dotProduct + 0.0697 * dotProduct * dotProduct;
                    vertexCoverageScales[i] += (aWeights[i] / fittedWeight) / double(sampleCount);
                    std::cout << direction.z << "," << dotProduct << "," << aWeights[i] << std::endl;
                }
                
            }
            
            std::cout << "Vertex coverage scales: \n";
            for (int i = 0; i < 9; i += 1) {
                std::cout << vertexCoverageScales[i] << ", ";
            }
            std::cout << "\n";
        }
        
        return gram;
    }
    
    Eigen::MatrixXd computeGGXGramMatrixBezier(float alpha, bool fixedNormal) {
        using namespace Eigen;
        
        const u64 sampleCount = 8192;
        double sampleScale = fixedNormal ? 2 * M_PI / double(sampleCount) : 4 * M_PI / double(sampleCount);
        
        const u64 brdfSampleCount = 8192;
        double brdfSampleScale = 1.f / double(brdfSampleCount);
        
        Microsurface *microsurface = new MicrosurfaceConductor(false, false, alpha, alpha);
        
        MatrixXd gram = MatrixXd::Zero(36, 36);
        
        for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
            vec2 sample = sampleHammersley(sampleIt, sampleCount);
            vec3 direction = fixedNormal ? sampleUniformHemisphere(sample.x, sample.y) : sampleUniformSphere(sample);
            
            vec3 N = fixedNormal ? vec3(0, 0, 1) : direction;
            mat3 tangentToWorld = makeOrthogonalBasis(N); // local to world
            mat3 worldToTangent = transpose(tangentToWorld);
            
            double bWeights[36] = { 0.f };
            
            u32 i0, i1, i2;
            AmbientDice::VertexWeights<double> weights[3];
            AmbientDice::hybridCubicBezierWeights(direction, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
            
            bWeights[3 * i0 + 0] = weights[0].value;
            bWeights[3 * i0 + 1] = weights[0].directionalDerivativeU;
            bWeights[3 * i0 + 2] = weights[0].directionalDerivativeV;
            
            bWeights[3 * i1 + 0] = weights[1].value;
            bWeights[3 * i1 + 1] = weights[1].directionalDerivativeU;
            bWeights[3 * i1 + 2] = weights[1].directionalDerivativeV;
            
            bWeights[3 * i2 + 0] = weights[2].value;
            bWeights[3 * i2 + 1] = weights[2].directionalDerivativeU;
            bWeights[3 * i2 + 2] = weights[2].directionalDerivativeV;
            
            double aWeights[36] = { 0.f };
            
            vec3 outputDirectionTangent = worldToTangent * direction;
            if (fixedNormal) {
                // Reflect the direction against the normal.
                outputDirectionTangent.x *= -1;
                outputDirectionTangent.y *= -1;
            }
            
            for (u64 brdfSampleIt = 0; brdfSampleIt < brdfSampleCount; brdfSampleIt += 1) {
                vec3 brdfTangentDirection = microsurface->sample(outputDirectionTangent);
                vec3 brdfWorldDirection = tangentToWorld * brdfTangentDirection;
                
                AmbientDice::hybridCubicBezierWeights(brdfWorldDirection, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
                
                aWeights[3 * i0 + 0] += brdfSampleScale * weights[0].value;
                aWeights[3 * i0 + 1] += brdfSampleScale * weights[0].directionalDerivativeU;
                aWeights[3 * i0 + 2] += brdfSampleScale * weights[0].directionalDerivativeV;
                
                aWeights[3 * i1 + 0] += brdfSampleScale * weights[1].value;
                aWeights[3 * i1 + 1] += brdfSampleScale * weights[1].directionalDerivativeU;
                aWeights[3 * i1 + 2] += brdfSampleScale * weights[1].directionalDerivativeV;
                
                aWeights[3 * i2 + 0] += brdfSampleScale * weights[2].value;
                aWeights[3 * i2 + 1] += brdfSampleScale * weights[2].directionalDerivativeU;
                aWeights[3 * i2 + 2] += brdfSampleScale * weights[2].directionalDerivativeV;
            }
            
            for (u64 lobeAIt = 0; lobeAIt < 36; ++lobeAIt)
            {
                for (u64 lobeBIt = lobeAIt; lobeBIt < 36; ++lobeBIt)
                {
                    double delta = aWeights[lobeAIt] * bWeights[lobeBIt] * sampleScale;
                    gram(lobeAIt, lobeBIt) += delta;
                    
                    if (lobeBIt != lobeAIt) {
                        gram(lobeBIt, lobeAIt) += delta;
                    }
                }
            }
            
        }
        
        delete microsurface;
        
        return gram;
    }
    
    Eigen::MatrixXd computeGGXGramMatrixSRBF(float alpha, bool fixedNormal) {
        using namespace Eigen;
        
        const u64 sampleCount = 4096;
        double sampleScale = fixedNormal ? 2 * M_PI / double(sampleCount) : 4 * M_PI / double(sampleCount);
        
        const u64 brdfSampleCount = 4096;
        double brdfSampleScale = 1.f / double(brdfSampleCount);
        
        Microsurface *microsurface = new MicrosurfaceConductor(false, false, alpha, alpha);
        
        MatrixXd gram = MatrixXd::Zero(vertexCount, vertexCount);
        
        for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
            vec2 sample = sampleHammersley(sampleIt, sampleCount);
            vec3 direction = fixedNormal ? sampleUniformHemisphere(sample.x, sample.y) : sampleUniformSphere(sample);
            
            vec3 N = fixedNormal ? vec3(0, 0, 1) : direction;
            mat3 tangentToWorld = makeOrthogonalBasis(N); // local to world
            mat3 worldToTangent = transpose(tangentToWorld);
            
            double bWeights[12] = { 0.f };
            AmbientDice::srbfWeights(direction, bWeights);
            
            double aWeights[12] = { 0.0 };
            
            vec3 outputDirectionTangent = worldToTangent * direction;
            if (fixedNormal) {
                // Reflect the direction against the normal.
                outputDirectionTangent.x *= -1;
                outputDirectionTangent.y *= -1;
            }
            
            for (u64 brdfSampleIt = 0; brdfSampleIt < brdfSampleCount; brdfSampleIt += 1) {
                vec3 brdfTangentDirection = microsurface->sample(outputDirectionTangent);
                vec3 brdfWorldDirection = tangentToWorld * brdfTangentDirection;
                if (fixedNormal && brdfWorldDirection.z < 0.f) {
                    continue;
                }
                
                double aWeightsLocal[12] = { 0.f };
                AmbientDice::srbfWeights(brdfWorldDirection, aWeightsLocal);
                
                for (u64 i = 0; i < 12; i += 1) {
                    aWeights[i] += aWeightsLocal[i] * brdfSampleScale;
                }
            }
            
            for (u64 lobeAIt = 0; lobeAIt < vertexCount; ++lobeAIt)
            {
                for (u64 lobeBIt = lobeAIt; lobeBIt < vertexCount; ++lobeBIt)
                {
                    double delta = aWeights[lobeAIt] * bWeights[lobeBIt] * sampleScale;
                    gram(lobeAIt, lobeBIt) += delta;
                    
                    if (lobeBIt != lobeAIt) {
                        gram(lobeBIt, lobeAIt) += delta;
                    }
                }
            }
        }
        
        delete microsurface;
        
        return gram;
    }
    
    AmbientDice ambientDiceConvertRadianceToSpecularBezier(const AmbientDice &ambientDiceRadiance) {
        using namespace Eigen;
        
        MatrixXd hemisphereGram = hemisphericalIntegral ? AmbientDice::computeGramMatrixBezier(/*hemispherical =*/ true) : AmbientDice::computeGramMatrixBezier();
        MatrixXd resultMatrix = pseudoInverse(AmbientDice::computeGramMatrixBezier()) * computeGGXGramMatrixBezier(ggxAlpha, hemisphericalIntegral);
        
        AmbientDice specular = { };
        
        for (u64 vert = 0; vert < 12; vert += 1) {
            for (u64 otherVert = 0; otherVert < 12; otherVert += 1) {
                specular.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(3 * vert, 3 * otherVert);
                specular.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].directionalDerivativeU * (float)resultMatrix(3 * vert, 3 * otherVert + 1);
                specular.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].directionalDerivativeV * (float)resultMatrix(3 * vert, 3 * otherVert + 2);
                
                specular.vertices[vert].directionalDerivativeU += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(3 * vert + 1, 3 * otherVert);
                specular.vertices[vert].directionalDerivativeU += ambientDiceRadiance.vertices[otherVert].directionalDerivativeU * (float)resultMatrix(3 * vert + 1, 3 * otherVert + 1);
                specular.vertices[vert].directionalDerivativeU += ambientDiceRadiance.vertices[otherVert].directionalDerivativeV * (float)resultMatrix(3 * vert + 1, 3 * otherVert + 2);
                
                specular.vertices[vert].directionalDerivativeV += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(3 * vert + 2, 3 * otherVert);
                specular.vertices[vert].directionalDerivativeV += ambientDiceRadiance.vertices[otherVert].directionalDerivativeU * (float)resultMatrix(3 * vert + 2, 3 * otherVert + 1);
                specular.vertices[vert].directionalDerivativeV += ambientDiceRadiance.vertices[otherVert].directionalDerivativeV * (float)resultMatrix(3 * vert + 2, 3 * otherVert + 2);
            }
        }
        
        return specular;
    }
    
    AmbientDice ambientDiceConvertRadianceToSpecularSRBF(const AmbientDice &ambientDiceRadiance) {
        using namespace Eigen;
        
        MatrixXd hemisphereGram = hemisphericalIntegral ? AmbientDice::computeGramMatrixSRBF(/*hemispherical =*/ true) : AmbientDice::computeGramMatrixSRBF();
        MatrixXd resultMatrix = pseudoInverse(hemisphereGram) * computeGGXGramMatrixSRBF(ggxAlpha, hemisphericalIntegral);
        
        std::cout << "Radiance to irradiance matrix: " << std::endl;
        std::cout << resultMatrix << std::endl;
        
        AmbientDice irradiance = { };
        
        for (u64 vert = 0; vert < vertexCount; vert += 1) {
            for (u64 otherVert = 0; otherVert < vertexCount; otherVert += 1) {
                irradiance.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(vert, otherVert);
            }
        }
        
        return irradiance;
    }
    
    AmbientDice ambientDiceConvertRadianceToIrradianceBezier(const AmbientDice &ambientDiceRadiance) {
        using namespace Eigen;
        
        MatrixXd resultMatrix = pseudoInverse(AmbientDice::computeGramMatrixBezier(hemisphericalIntegral)) * computeCosineGramMatrixBezier(hemisphericalIntegral);
        
        std::cout << "Radiance to irradiance matrix: " << std::endl;
        std::cout << resultMatrix << std::endl;
        
        AmbientDice irradiance = { };
        
        for (u64 vert = 0; vert < 12; vert += 1) {
            for (u64 otherVert = 0; otherVert < 12; otherVert += 1) {
                irradiance.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(3 * vert, 3 * otherVert);
                irradiance.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].directionalDerivativeU * (float)resultMatrix(3 * vert, 3 * otherVert + 1);
                irradiance.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].directionalDerivativeV * (float)resultMatrix(3 * vert, 3 * otherVert + 2);
                
                irradiance.vertices[vert].directionalDerivativeU += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(3 * vert + 1, 3 * otherVert);
                irradiance.vertices[vert].directionalDerivativeU += ambientDiceRadiance.vertices[otherVert].directionalDerivativeU * (float)resultMatrix(3 * vert + 1, 3 * otherVert + 1);
                irradiance.vertices[vert].directionalDerivativeU += ambientDiceRadiance.vertices[otherVert].directionalDerivativeV * (float)resultMatrix(3 * vert + 1, 3 * otherVert + 2);
                
                irradiance.vertices[vert].directionalDerivativeV += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(3 * vert + 2, 3 * otherVert);
                irradiance.vertices[vert].directionalDerivativeV += ambientDiceRadiance.vertices[otherVert].directionalDerivativeU * (float)resultMatrix(3 * vert + 2, 3 * otherVert + 1);
                irradiance.vertices[vert].directionalDerivativeV += ambientDiceRadiance.vertices[otherVert].directionalDerivativeV * (float)resultMatrix(3 * vert + 2, 3 * otherVert + 2);
            }
        }
        
        return irradiance;
    }
    
    AmbientDice ambientDiceConvertRadianceToIrradianceSRBF(const AmbientDice &ambientDiceRadiance) {
        using namespace Eigen;
        
        MatrixXd resultMatrix = pseudoInverse(AmbientDice::computeGramMatrixSRBF(hemisphericalIntegral)) * computeCosineGramMatrixSRBF(hemisphericalIntegral);
        
        std::cout << "Radiance to irradiance matrix: " << std::endl;
        std::cout << resultMatrix << std::endl;
        
        AmbientDice irradiance = { };
        
        for (u64 vert = 0; vert < vertexCount; vert += 1) {
            for (u64 otherVert = 0; otherVert < vertexCount; otherVert += 1) {
                irradiance.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(vert, otherVert);
            }
        }
        
        return irradiance;
    }
    
    
    //    AmbientDice ExperimentAmbientDice::solveAmbientDiceLeastSquares(ImageBase<vec3>& directions, const Image& irradiance)
    //    {
    //        using namespace Eigen;
    //
    //        AmbientDice ambientDice;
    //
    //        const u64 sampleCount = directions.getPixelCount();
    //
    //        MatrixXf A = MatrixXf::Zero(sampleCount, 36);
    //
    //        for (u64 sampleIt = 0; sampleIt < sampleCount; ++sampleIt)
    //        {
    //            const vec3& direction = directions.at(sampleIt);
    //
    //            u32 i0, i1, i2;
    //            AmbientDice::VertexWeights weights[3];
    //            AmbientDice::hybridCubicBezierWeights(direction, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
    //
    //            A(sampleIt, 3 * i0) = weights[0].value;
    //            A(sampleIt, 3 * i0 + 1) = weights[0].directionalDerivativeU;
    //            A(sampleIt, 3 * i0 + 2) = weights[0].directionalDerivativeV;
    //
    //            A(sampleIt, 3 * i1) = weights[1].value;
    //            A(sampleIt, 3 * i1 + 1) = weights[1].directionalDerivativeU;
    //            A(sampleIt, 3 * i1 + 2) = weights[1].directionalDerivativeV;
    //
    //            A(sampleIt, 3 * i2) = weights[2].value;
    //            A(sampleIt, 3 * i2 + 1) = weights[2].directionalDerivativeU;
    //            A(sampleIt, 3 * i2 + 2) = weights[2].directionalDerivativeV;
    //
    //        }
    //
    //        auto solver = A.jacobiSvd(ComputeThinU | ComputeThinV);
    //
    //        VectorXf b;
    //        b.resize(sampleCount);
    //
    //        for (u32 channelIt = 0; channelIt < 3; ++channelIt)
    //        {
    //            for (u64 sampleIt = 0; sampleIt < sampleCount; ++sampleIt)
    //            {
    //                b[sampleIt] = irradiance.at(sampleIt)[channelIt];
    //            }
    //
    //            VectorXf x = solver.solve(b);
    //
    //            for (u64 basisIt = 0; basisIt < 12; ++basisIt)
    //            {
    //                ambientDice.vertices[basisIt].value[channelIt] = x[3 * basisIt];
    //                ambientDice.vertices[basisIt].directionalDerivativeU[channelIt] = x[3 * basisIt + 1];
    //                ambientDice.vertices[basisIt].directionalDerivativeV[channelIt] = x[3 * basisIt + 2];
    //            }
    //        }
    //
    //        return ambientDice;
    //    }
    
    Eigen::MatrixXd AmbientDice::computeGramMatrixBezier(bool hemispherical) {
        using namespace Eigen;
        
        const u64 sampleCount = 32768;
        double sampleScale = hemispherical ? 2 * M_PI / double(sampleCount) : 4 * M_PI / double(sampleCount);
        
        AmbientDice ambientDice;
        
        MatrixXd gram = MatrixXd::Zero(36, 36);
        
        for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
            dvec2 sample = sampleHammersleyDouble(sampleIt, sampleCount);
            dvec3 direction = hemispherical ? sampleUniformHemisphereDouble(sample.x, sample.y) : sampleUniformSphereDouble(sample.x, sample.y);
            
            double allWeights[36] = { 0.f };
            
            u32 i0, i1, i2;
            AmbientDice::VertexWeights<double> weights[3];
            AmbientDice::hybridCubicBezierWeights(direction, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
            
            allWeights[3 * i0 + 0] = weights[0].value;
            allWeights[3 * i0 + 1] = weights[0].directionalDerivativeU;
            allWeights[3 * i0 + 2] = weights[0].directionalDerivativeV;
            
            allWeights[3 * i1 + 0] = weights[1].value;
            allWeights[3 * i1 + 1] = weights[1].directionalDerivativeU;
            allWeights[3 * i1 + 2] = weights[1].directionalDerivativeV;
            
            allWeights[3 * i2 + 0] = weights[2].value;
            allWeights[3 * i2 + 1] = weights[2].directionalDerivativeU;
            allWeights[3 * i2 + 2] = weights[2].directionalDerivativeV;
            
            for (u64 lobeAIt = 0; lobeAIt < 36; ++lobeAIt)
            {
                for (u64 lobeBIt = lobeAIt; lobeBIt < 36; ++lobeBIt)
                {
                    double delta = allWeights[lobeAIt] * allWeights[lobeBIt] * sampleScale;
                    gram(lobeAIt, lobeBIt) += delta;
                    
                    if (lobeBIt != lobeAIt) {
                        gram(lobeBIt, lobeAIt) += delta;
                    }
                }
            }
        }
        
        return gram;
    }
    
    Eigen::MatrixXd AmbientDice::computeGramMatrixLinear(bool hemispherical) {
        using namespace Eigen;
        
        const u64 sampleCount = 32768;
        double sampleScale = hemispherical ? 2 * M_PI / double(sampleCount) : 4 * M_PI / double(sampleCount);
        
        AmbientDice ambientDice;
        
        MatrixXd gram = MatrixXd::Zero(12, 12);
        
        for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
            dvec2 sample = sampleHammersleyDouble(sampleIt, sampleCount);
            dvec3 direction = hemispherical ? sampleUniformHemisphereDouble(sample.x, sample.y) : sampleUniformSphereDouble(sample.x, sample.y);
            
            u32 triIndex;
            u32 i0, i1, i2;
            float b0, b1, b2;
            AmbientDice::computeBarycentrics(direction, &triIndex, &i0, &i1, &i2, &b0, &b1, &b2);
            
            
            gram(i0, i0) += b0 * b0 * sampleScale;
            gram(i0, i1) += b0 * b1 * sampleScale;
            gram(i0, i1) += b0 * b2 * sampleScale;
            gram(i1, i1) += b1 * b1 * sampleScale;
            gram(i1, i2) += b1 * b2 * sampleScale;
            gram(i2, i2) += b2 * b2 * sampleScale;
        }
        
        for (u64 lobeAIt = 0; lobeAIt < 12; ++lobeAIt)
        {
            for (u64 lobeBIt = lobeAIt; lobeBIt < 12; ++lobeBIt)
            {
                gram(lobeBIt, lobeAIt) = gram(lobeAIt, lobeBIt);
            }
        }
        
        return gram;
    }
    
    Eigen::MatrixXd AmbientDice::computeGramMatrixSRBF(bool hemispherical) {
        using namespace Eigen;
        
        const u64 sampleCount = 32768;
        double sampleScale = hemispherical ? 2 * M_PI / double(sampleCount) : 4 * M_PI / double(sampleCount);
        
        AmbientDice ambientDice;
        
        MatrixXd gram = MatrixXd::Zero(vertexCount, vertexCount);
        
        for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
            dvec2 sample = sampleHammersleyDouble(sampleIt, sampleCount);
            dvec3 direction = hemispherical ? sampleUniformHemisphereDouble(sample.x, sample.y) : sampleUniformSphereDouble(sample.x, sample.y);
            
            double allWeights[12] = { 0.f };
            AmbientDice::srbfWeights(direction, allWeights);
            
            for (u64 lobeAIt = 0; lobeAIt < vertexCount; ++lobeAIt)
            {
                for (u64 lobeBIt = lobeAIt; lobeBIt < vertexCount; ++lobeBIt)
                {
                    double delta = allWeights[lobeAIt] * allWeights[lobeBIt] * sampleScale;
                    gram(lobeAIt, lobeBIt) += delta;
                    
                    if (lobeBIt != lobeAIt) {
                        gram(lobeBIt, lobeAIt) += delta;
                    }
                }
            }
        }
        
        return gram;
    }
    
    AmbientDice ExperimentAmbientDice::solveAmbientDiceLeastSquaresBezier(ImageBase<vec3>& directions, const Image& irradiance)
    {
        using namespace Eigen;
        
        AmbientDice ambientDice;
        
        MatrixXd moments = MatrixXd::Zero(36, 3);
        
        ivec2 imageSize = directions.getSize();
        if (hemisphericalIntegral) {
            imageSize.y /= 2;
        }
        directions.forPixels2D([&](const vec3& direction, ivec2 pixelPos)
                               {
                                   float texelArea = latLongTexelArea(pixelPos, imageSize);
                                   //                                              float texelArea = 1.f / directions.getPixelCount();
                                   
                                   const vec4& colour = irradiance.at(pixelPos);
                                   
                                   u32 i0, i1, i2;
                                   AmbientDice::VertexWeights<double> weights[3];
                                   AmbientDice::hybridCubicBezierWeights(direction, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
                                   
                                   moments(3 * i0 + 0, 0) += weights[0].value * colour.r * texelArea;
                                   moments(3 * i0 + 1, 0) += weights[0].directionalDerivativeU * colour.r * texelArea;
                                   moments(3 * i0 + 2, 0) += weights[0].directionalDerivativeV * colour.r * texelArea;
                                   moments(3 * i1 + 0, 0) += weights[1].value * colour.r * texelArea;
                                   moments(3 * i1 + 1, 0) += weights[1].directionalDerivativeU * colour.r * texelArea;
                                   moments(3 * i1 + 2, 0) += weights[1].directionalDerivativeV * colour.r * texelArea;
                                   moments(3 * i2 + 0, 0) += weights[2].value * colour.r * texelArea;
                                   moments(3 * i2 + 1, 0) += weights[2].directionalDerivativeU * colour.r * texelArea;
                                   moments(3 * i2 + 2, 0) += weights[2].directionalDerivativeV * colour.r * texelArea;
                                   moments(3 * i0 + 0, 1) += weights[0].value * colour.g * texelArea;
                                   moments(3 * i0 + 1, 1) += weights[0].directionalDerivativeU * colour.g * texelArea;
                                   moments(3 * i0 + 2, 1) += weights[0].directionalDerivativeV * colour.g * texelArea;
                                   moments(3 * i1 + 0, 1) += weights[1].value * colour.g * texelArea;
                                   moments(3 * i1 + 1, 1) += weights[1].directionalDerivativeU * colour.g * texelArea;
                                   moments(3 * i1 + 2, 1) += weights[1].directionalDerivativeV * colour.g * texelArea;
                                   moments(3 * i2 + 0, 1) += weights[2].value * colour.g * texelArea;
                                   moments(3 * i2 + 1, 1) += weights[2].directionalDerivativeU * colour.g * texelArea;
                                   moments(3 * i2 + 2, 1) += weights[2].directionalDerivativeV * colour.g * texelArea;
                                   moments(3 * i0 + 0, 2) += weights[0].value * colour.b * texelArea;
                                   moments(3 * i0 + 1, 2) += weights[0].directionalDerivativeU * colour.b * texelArea;
                                   moments(3 * i0 + 2, 2) += weights[0].directionalDerivativeV * colour.b * texelArea;
                                   moments(3 * i1 + 0, 2) += weights[1].value * colour.b * texelArea;
                                   moments(3 * i1 + 1, 2) += weights[1].directionalDerivativeU * colour.b * texelArea;
                                   moments(3 * i1 + 2, 2) += weights[1].directionalDerivativeV * colour.b * texelArea;
                                   moments(3 * i2 + 0, 2) += weights[2].value * colour.b * texelArea;
                                   moments(3 * i2 + 1, 2) += weights[2].directionalDerivativeU * colour.b * texelArea;
                                   moments(3 * i2 + 2, 2) += weights[2].directionalDerivativeV * colour.b * texelArea;
                               });
        
        MatrixXd gram = AmbientDice::computeGramMatrixBezier();
        
        auto solver = gram.jacobiSvd(ComputeThinU | ComputeThinV);
        
        VectorXd b;
        b.resize(36);
        
        for (u32 channelIt = 0; channelIt < 3; ++channelIt)
        {
            for (u64 lobeIt = 0; lobeIt < 36; ++lobeIt)
            {
                b[lobeIt] = moments(lobeIt, channelIt);
            }
            
            VectorXd x = solver.solve(b);
            
            for (u64 basisIt = 0; basisIt < 12; ++basisIt)
            {
                ambientDice.vertices[basisIt].value[channelIt] = x[3 * basisIt];
                ambientDice.vertices[basisIt].directionalDerivativeU[channelIt] = x[3 * basisIt + 1];
                ambientDice.vertices[basisIt].directionalDerivativeV[channelIt] = x[3 * basisIt + 2];
            }
        }
        
        return ambientDice;
    }
    
    AmbientDice ExperimentAmbientDice::solveAmbientDiceLeastSquaresBezierYCoCg(ImageBase<vec3>& directions, const Image& irradiance)
    {
        using namespace Eigen;
        
        AmbientDice ambientDice;
        
        VectorXd momentsY = VectorXd::Zero(36);
        VectorXd momentsCo = VectorXd::Zero(12);
        VectorXd momentsCg = VectorXd::Zero(12);
        
        ivec2 imageSize = directions.getSize();
        if (hemisphericalIntegral) {
            imageSize.y /= 2;
        }
        directions.forPixels2D([&](const vec3& direction, ivec2 pixelPos)
                               {
                                   float texelArea = latLongTexelArea(pixelPos, imageSize);
                                   //                                              float texelArea = 1.f / directions.getPixelCount();
                                   
                                   const vec4& colour = irradiance.at(pixelPos);
                                   
                                   vec3 colourYCoCg = RGBToYCoCg(vec3(colour.r, colour.g, colour.b));
                                   
                                   
                                   u32 i0, i1, i2;
                                   AmbientDice::VertexWeights<double> weights[3];
                                   AmbientDice::hybridCubicBezierWeights(direction, &i0, &i1, &i2, &weights[0], &weights[1], &weights[2]);
                                   
                                   u32 triIndex;
                                   float b0, b1, b2;
                                   AmbientDice::computeBarycentrics(direction, &triIndex, &i0, &i1, &i2, &b0, &b1, &b2);
                                   
                                   momentsY[3 * i0 + 0] += weights[0].value * colourYCoCg.r * texelArea;
                                   momentsY[3 * i0 + 1] += weights[0].directionalDerivativeU * colourYCoCg.r * texelArea;
                                   momentsY[3 * i0 + 2] += weights[0].directionalDerivativeV * colourYCoCg.r * texelArea;
                                   momentsY[3 * i1 + 0] += weights[1].value * colourYCoCg.r * texelArea;
                                   momentsY[3 * i1 + 1] += weights[1].directionalDerivativeU * colourYCoCg.r * texelArea;
                                   momentsY[3 * i1 + 2] += weights[1].directionalDerivativeV * colourYCoCg.r * texelArea;
                                   momentsY[3 * i2 + 0] += weights[2].value * colourYCoCg.r * texelArea;
                                   momentsY[3 * i2 + 1] += weights[2].directionalDerivativeU * colourYCoCg.r * texelArea;
                                   momentsY[3 * i2 + 2] += weights[2].directionalDerivativeV * colourYCoCg.r * texelArea;
                                   
                                   momentsCo[i0] += b0 * colourYCoCg.g * texelArea;
                                   momentsCo[i1] += b1 * colourYCoCg.g * texelArea;
                                   momentsCo[i2] += b2 * colourYCoCg.g * texelArea;
                                   
                                   momentsCg[i0] += b0 * colourYCoCg.b * texelArea;
                                   momentsCg[i1] += b1 * colourYCoCg.b * texelArea;
                                   momentsCg[i2] += b2 * colourYCoCg.b * texelArea;
                               });
        
        MatrixXd gramBezier = AmbientDice::computeGramMatrixBezier();
        MatrixXd gramLinear = AmbientDice::computeGramMatrixLinear();
        
        VectorXd Y = gramBezier.jacobiSvd(ComputeThinU | ComputeThinV).solve(momentsY);
        
        const auto linearSolver = gramLinear.jacobiSvd(ComputeThinU | ComputeThinV);
        VectorXd Co = linearSolver.solve(momentsCo);
        VectorXd Cg = linearSolver.solve(momentsCg);
        
        for (u64 basisIt = 0; basisIt < 12; ++basisIt)
        {
            ambientDice.vertices[basisIt].value[0] = Y[3 * basisIt];
            ambientDice.vertices[basisIt].directionalDerivativeU[0] = Y[3 * basisIt + 1];
            ambientDice.vertices[basisIt].directionalDerivativeV[0] = Y[3 * basisIt + 2];
            
            ambientDice.vertices[basisIt].value[1] = Co[basisIt];
            ambientDice.vertices[basisIt].value[2] = Cg[basisIt];
        }
        
        return ambientDice;
    }
    
    AmbientDice ExperimentAmbientDice::solveAmbientDiceLeastSquaresSRBF(ImageBase<vec3>& directions, const Image& irradiance)
    {
//        using namespace Eigen;
//
//        AmbientDice ambientDice;
//
//        const u64 sampleCount = hemisphericalIntegral ? directions.getPixelCount() / 2 : directions.getPixelCount();
//
//        MatrixXf A = MatrixXf::Zero(sampleCount, 12);
//
//        for (u64 sampleIt = 0; sampleIt < sampleCount; ++sampleIt)
//        {
//            const vec3& direction = directions.at(sampleIt);
//
//            float weights[12] = { 0.f };
//            AmbientDice::srbfWeights(direction, weights);
//
//            for (u64 i = 0; i < 12; i += 1) {
//                A(sampleIt, i) = weights[i];
//            }
//
//        }
//
//        auto solver = A.jacobiSvd(ComputeThinU | ComputeThinV);
//
//        VectorXf b;
//        b.resize(sampleCount);
//
//        for (u32 channelIt = 0; channelIt < 3; ++channelIt)
//        {
//            for (u64 sampleIt = 0; sampleIt < sampleCount; ++sampleIt)
//            {
//                b[sampleIt] = irradiance.at(sampleIt)[channelIt];
//            }
//
//            VectorXf x = solver.solve(b);
//
//            for (u64 basisIt = 0; basisIt < 12; ++basisIt)
//            {
//                ambientDice.vertices[basisIt].value[channelIt] = x[basisIt];
//            }
//        }
//
//        return ambientDice;

        using namespace Eigen;
        
        AmbientDice ambientDice;
        
        VectorXd momentsR = VectorXd::Zero(vertexCount);
        VectorXd momentsG = VectorXd::Zero(vertexCount);
        VectorXd momentsB = VectorXd::Zero(vertexCount);
        
        ivec2 imageSize = directions.getSize();
        if (hemisphericalIntegral) {
            imageSize.y /= 2;
        }
        directions.forPixels2D([&](const vec3& direction, ivec2 pixelPos)
                               {
                                   float texelArea = latLongTexelArea(pixelPos, imageSize);
                                   //                                              float texelArea = 1.f / directions.getPixelCount();
                                   
                                   const vec4& colour = irradiance.at(pixelPos);
                                   
                                   double weights[12];
                                   AmbientDice::srbfWeights(direction, weights);
                                   
                                   for (size_t i = 0; i < vertexCount; i += 1) {
                                       momentsR[i] += weights[i] * colour.r * texelArea;
                                       momentsG[i] += weights[i] * colour.g * texelArea;
                                       momentsB[i] += weights[i] * colour.b * texelArea;
                                   }
                               });
        
        MatrixXd gram = AmbientDice::computeGramMatrixSRBF();
        
        const auto solver = gram.jacobiSvd(ComputeThinU | ComputeThinV);
        VectorXd R = solver.solve(momentsR);
        VectorXd G = solver.solve(momentsG);
        VectorXd B = solver.solve(momentsB);
        
        for (u64 basisIt = 0; basisIt < vertexCount; ++basisIt)
        {
            ambientDice.vertices[basisIt].value[0] = R[basisIt];
            ambientDice.vertices[basisIt].value[1] = G[basisIt];
            ambientDice.vertices[basisIt].value[2] = B[basisIt];
        }
        
        return ambientDice;
    }
    
    // Normal is assumed to be at (0, 0, 1)
    inline double evaluateSRBFBasisWeightGGX(float ggxAlpha, float vertexTheta, float vertexPhi, float viewDirTheta, float viewDirPhi) {
        
        vec3 V = vec3(cos(viewDirPhi) * sin(viewDirTheta), sin(viewDirPhi) * sin(viewDirTheta), cos(viewDirTheta));
        if (V.z <= 0.f) {
            return 0.0;
        }
        
        vec3 vertexTangent = vec3(cos(vertexPhi) * sin(vertexTheta), sin(vertexPhi) * sin(vertexTheta), cos(vertexTheta));
        
        const u64 sampleCount = 1536;
        const double sampleScale = 1.0 / double(sampleCount);
        
        double integral = 0.0;
        for (u64 sampleIt = 1; sampleIt <= sampleCount; sampleIt += 1) {
            vec2 sampleUV = vec2(sampleHalton(sampleIt, 2), sampleHalton(sampleIt, 3));
            vec3 H = sampleGGXVNDF(V, ggxAlpha, ggxAlpha, sampleUV.x, sampleUV.y); // depends on viewDirTheta, viewDirPhi
            vec3 lightDirectionTangent = reflect(-V, H); // depends on viewDirTheta, viewDirPhi
            
            float f0 = 1.0f; // 0.1f;
            float f90 = 1.0f;
            
            //Specular
            float Vis = SmithGGXMaskingShadowingG2OverG1Reflection(V, lightDirectionTangent, H, ggxAlpha); // depends on viewDirTheta, viewDirPhi
            double F = F_Schlick(f0, f90, saturate(dot(V, H))); // depends on viewDirTheta, viewDirPhi
            
            double brdf = F * Vis;
            
            double basis = 0.0;
            {
                double dotProduct = max(dot(lightDirectionTangent, vertexTangent), 0.f); // depends on viewDirTheta, viewDirPhi, vertexTheta, vertexPhi (or, alternately, the angle between the view dir and the vertex tangent)
                double cos2 = dotProduct * dotProduct;
                double cos4 = cos2 * cos2;
                basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
            }
            
            integral += brdf * basis * sampleScale;
        }
        
        return integral;
    }
    
    /// All inputs are in world space.
    inline double evaluateSRBFBasisWeightMS(const Microsurface &microsurface, const vec3 vertex, const vec3 normal, const vec3 viewDirection) {
        
        mat3 worldToTangent = transpose(makeOrthogonalBasis(normal));
        vec3 V = worldToTangent * viewDirection;
        if (V.z <= 0.f) {
            return 0.0;
        }
        
        vec3 vertexTangent = worldToTangent * vertex;
        
        const u64 sampleCount = 4096;
        const double sampleScale = 1.0 / double(sampleCount);
        
        double integral = 0.0;
        for (u64 sampleIt = 1; sampleIt <= sampleCount; sampleIt += 1) {
            vec3 H = microsurface.sample(V);
            vec3 lightDirectionTangent = reflect(-V, H);
            
            // How much does the average reflected direction lie along the basis function?
            double basis = 0.0;
            {
                double dotProduct = max(dot(lightDirectionTangent, vertexTangent), 0.f);
                double cos2 = dotProduct * dotProduct;
                double cos4 = cos2 * cos2;
                basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
            }
            
            integral += basis * sampleScale;
        }
        
        return integral;
    }
    
    /// All inputs are in world space.
    inline vec2 evaluateDFGWeightGGX(float ggxAlpha, const vec3 normal, const vec3 viewDirection) {
        
        mat3 worldToTangent = transpose(makeOrthogonalBasis(normal));
        vec3 V = worldToTangent * viewDirection;
        if (V.z <= 0.f) {
            return vec2(0.0);
        }
        
        const u64 sampleCount = 1024;
        const double sampleScale = 1.0 / double(sampleCount);
        
        dvec2 integral = dvec2(0.0);
        for (u64 sampleIt = 1; sampleIt <= sampleCount; sampleIt += 1) {
            vec2 sampleUV = vec2(sampleHalton(sampleIt, 2), sampleHalton(sampleIt, 3));
            vec3 H = sampleGGXVNDF(V, ggxAlpha, ggxAlpha, sampleUV.x, sampleUV.y);
            vec3 lightDirectionTangent = reflect(-V, H);
            
            //Specular
            float Vis = SmithGGXMaskingShadowingG2OverG1Reflection(V, lightDirectionTangent, H, ggxAlpha);
            
            if (lightDirectionTangent.z < 0.f) {
                Vis = 0.0;
            }
            
            float VdotH = dot(H, V);
            float fresnel = pow( 1.f - VdotH, 5.0 );
            
            dvec2 brdf = dvec2((1 - fresnel) * Vis, fresnel * Vis);
            integral += brdf * sampleScale;
        }
        
        return vec2(integral.x, integral.y);
    }
    
    /// All inputs are in world space.
    inline vec2 evaluateSRBFBasisWeightGGX(float ggxAlpha, const vec3 vertex, const vec3 normal, const vec3 viewDirection) {
        
        mat3 worldToTangent = transpose(makeOrthogonalBasis(normal));
        vec3 V = worldToTangent * viewDirection;
        if (V.z <= 0.f) {
            return dvec2(0.0);
        }
        
        vec3 vertexTangent = worldToTangent * vertex;
        
        const u64 sampleCount = 4096;
        const double sampleScale = 1.0 / double(sampleCount);
        
        dvec2 integral = dvec2(0.0);
        for (u64 sampleIt = 1; sampleIt <= sampleCount; sampleIt += 1) {
            vec2 sampleUV = vec2(sampleHalton(sampleIt, 2), sampleHalton(sampleIt, 3));
            vec3 H = sampleGGXVNDF(V, ggxAlpha, ggxAlpha, sampleUV.x, sampleUV.y);
            vec3 lightDirectionTangent = reflect(-V, H);
            
            //Specular
            float Vis = SmithGGXMaskingShadowingG2OverG1Reflection(V, lightDirectionTangent, H, ggxAlpha);
            float VdotH = dot(H, V);
            float fresnel = pow( 1.f - VdotH, 5.0 );
            
            dvec2 brdf = dvec2((1 - fresnel) * Vis, fresnel * Vis);
            
            // How much does the average reflected direction lie along the basis function?
            double basis = 0.0;
            {
                double dotProduct = max(dot(lightDirectionTangent, vertexTangent), 0.f);
                double cos2 = dotProduct * dotProduct;
                double cos4 = cos2 * cos2;
                basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
            }
            
            integral += brdf * basis * sampleScale;
        }
        
        return vec2(integral.x, integral.y);
    }
    
    inline float square(float x) {
        return x * x;
    }
    
    inline float quart(float x) {
        return (x * x) * (x * x);
    }
    
    inline float basisFunction(float cosTheta) {
        float dotProduct = max(cosTheta, 0.f);
        float cos2 = dotProduct * dotProduct;
        float cos4 = cos2 * cos2;
        return 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
    }
    
    inline vec3 ggxDominantDirection(vec3 N, vec3 R, float roughness) {
        float smoothness = saturate(1.f - roughness);
        float lerpFactor = smoothness * (sqrt(smoothness) + roughness);
        return normalize(mix(N, R, lerpFactor));
    }
    
    const float parameters[10] = { -0.03480017115306019, 1.5767277269939315, 3.2915521747760006, -8.886052306193424, 5.289174934167271, 0.658318188157326, -0.9258960547724002, 2.9786527829025813, -2.0077225608393703, 0.2642150798240006 };
    
    inline vec2 lutValueApprox(float NdotV, float ggxAlpha) {
        const uint sampleCount = 512u;
        const float sampleScale = 1.f / float(sampleCount);
        
        NdotV = min(max(NdotV, 0.5f / 256.f), 0.999f);
        ggxAlpha = min(max(ggxAlpha, 0.5f / 256.f), 0.999f);
        
        vec3 viewDirection = vec3(0, sqrt(1.f - NdotV * NdotV), NdotV);
        vec3 R = vec3(-viewDirection.x, -viewDirection.y, viewDirection.z);
        vec3 reflectionDir = ggxDominantDirection(vec3(0, 0, 1), R, ggxAlpha);
        
        vec3 basisDirection = reflectionDir; // vec3(0, 0, 1);
        
        float RdotVert = dot(R, basisDirection);
        float basisInMirrorDir = basisFunction(RdotVert);
        
        float focusLerp = parameters[5] + parameters[6] * ggxAlpha + parameters[7] * ggxAlpha * ggxAlpha + parameters[8] * ggxAlpha * ggxAlpha * ggxAlpha + parameters[9] * ggxAlpha * ggxAlpha * ggxAlpha * ggxAlpha;
        float diffuseParam = mix(RdotVert, basisDirection.z, saturate(focusLerp));
        float diffuse = 0.06 + 0.129 * diffuseParam + 0.0697 * diffuseParam * diffuseParam;
        
        float alphaLerp = parameters[0] + parameters[1] * ggxAlpha + parameters[2] * ggxAlpha * ggxAlpha + parameters[3] * ggxAlpha * ggxAlpha * ggxAlpha + parameters[4] * ggxAlpha * ggxAlpha * ggxAlpha * ggxAlpha;
        
        float value = mix(basisInMirrorDir, diffuse, saturate(alphaLerp));
        
        vec2 groundTruth = vec2(0.0); // for f0 and f90MinusF0
        for (uint sampleIt = 0u; sampleIt < sampleCount; sampleIt += 1u) {
            vec2 sampleUV = sampleHammersley(sampleIt, sampleCount);
            vec3 H = sampleGGXVNDF(viewDirection, ggxAlpha, ggxAlpha, sampleUV.y, sampleUV.x);
            vec3 lightDirectionTangent = reflect(-viewDirection, H);
            
            //Specular
            float Vis = SmithGGXMaskingShadowingG2OverG1Reflection(viewDirection, lightDirectionTangent, H, ggxAlpha);
            
            float f0Weight = 1.f;
            float f90MinusF0Weight = pow(1.f - saturate(dot(viewDirection, H)), 5.f);  //native_powr(1.f - u, 5.f);
            
            float basis = basisFunction(dot(basisDirection, lightDirectionTangent));
            
            vec2 brdf = vec2(f0Weight - f90MinusF0Weight, f90MinusF0Weight) * Vis;
            if (lightDirectionTangent.z > 0.f) {
                groundTruth += basis * brdf * sampleScale;
            }
        }
        
        return groundTruth / vec2(value);
    }
    
    inline vec2 estimateSRBFBasisWeightGGXCustomFit(float ggxAlpha, const vec3 lobeDirection, const vec3 normal, const vec3 viewDirection) {
        float NdotV = dot(normal, viewDirection);
        if (NdotV < 0.f) {
            return vec2(0.f);
        }
        
        vec3 R = reflect(-viewDirection, normal);
        float RdotVert = dot(lobeDirection, R);
        
        float NdotLobe = dot(normal, lobeDirection);
        
        float basisInMirrorDir = basisFunction(RdotVert);
        
        float focusLerp = parameters[5] + parameters[6] * ggxAlpha + parameters[7] * ggxAlpha * ggxAlpha + parameters[8] * ggxAlpha * ggxAlpha * ggxAlpha + parameters[9] * ggxAlpha * ggxAlpha * ggxAlpha * ggxAlpha;
        float diffuseParam = mix(RdotVert, NdotLobe, saturate(focusLerp));
        float diffuse = 0.06 + 0.129 * diffuseParam + 0.0697 * diffuseParam * diffuseParam;
        
        float alphaLerp = parameters[0] + parameters[1] * ggxAlpha + parameters[2] * ggxAlpha * ggxAlpha + parameters[3] * ggxAlpha * ggxAlpha * ggxAlpha + parameters[4] * ggxAlpha * ggxAlpha * ggxAlpha * ggxAlpha;
        
        float value = mix(basisInMirrorDir, diffuse, saturate(alphaLerp));
    
        vec2 result = vec2(value);
        return result * lutValueApprox(NdotV, ggxAlpha);
    }
    
    inline float chebyshevPolynomial(float x, u32 order) {
        if (order == 0) {
            return 1.f;
        }
        if (order == 1) {
            return x;
        }
        return 2.f * x * chebyshevPolynomial(x, order - 1) - chebyshevPolynomial(x, order - 2);
    }
    
    inline float evaluateAmbientDiceCosineLobeDiffuseFromRadiance(float thetaLobe) {
        
        float cosThetaLobe = cos(thetaLobe);
        float sinThetaLobe = sin(thetaLobe);
        
        float cosThetaLobeSq = cosThetaLobe * cosThetaLobe;
        float cosThetaLobeP3 = cosThetaLobeSq * cosThetaLobe;
        float cosThetaLobeP4 = cosThetaLobeSq * cosThetaLobeSq;
        float cosThetaLobeP6 = cosThetaLobeP4 * cosThetaLobeSq;
        float cosThetaLobeP8 = cosThetaLobeP4 * cosThetaLobeP4;
        float cosThetaLobeP10 = cosThetaLobeP8 * cosThetaLobeSq;
        
        // If thetaLobe > pi/2 (so integration domain phi ∈ [0, pi], theta ∈ [thetaLobe - pi/2, pi/2]):
        float rightQuarterSphereClipped = (1167.f*cos(6*thetaLobe))/163840.f - (313.f*cos(4.f*thetaLobe))/61440.f - (8959.f*cos(2.f*thetaLobe))/245760 + (5.f*cos(8.f*thetaLobe))/49152 - (35.f*cos(10.f*thetaLobe))/98304.f + (67.f*sin(2.f*thetaLobe))/960.f + sin(4.f*thetaLobe)/384.f + (113.f*cos(2.f*thetaLobe))/(5760.f*pi) - cos(4.f*thetaLobe)/(576.f*pi) - (53.f*cos(6.f*thetaLobe))/(2560.f*pi) - cos(8.f*thetaLobe)/(4608.f*pi) + (5.f*cos(10.f*thetaLobe))/(4608.f*pi) + 1/(512.f*pi) + (67.f*atan((sqrt(2.f)*(cos(thetaLobe/2.f) - sin(thetaLobe/2.f)))/(2.f*cos(thetaLobe/2.f - pi/4.f)))*sin(2.f*thetaLobe))/(240.f*pi) + (atan((sqrt(2.f)*(cos(thetaLobe/2.f) - sin(thetaLobe/2.f)))/(2.f*cos(thetaLobe/2.f - pi/4.f)))*sin(4.f*thetaLobe))/(96.f*pi) + 2841.f/81920.f;
        
        // Otherwise, the right quarter sphere fully intersects with the BRDF and the left is partially clipped.
        float fullHemisphereClipped = (3.f*cosThetaLobeSq)/40.f + (41.f*cosThetaLobeP4)/192.f + (63.f*cosThetaLobeP6)/320.f - (15.f*cosThetaLobeP8)/32.f + (35.f*cosThetaLobeP10)/192.f + (31.f*cosThetaLobeSq)/(120.f*pi) - (23.f*cosThetaLobeP4)/(45.f*pi) - (73.f*cosThetaLobeP6)/(120.f*pi) + (17.f*cosThetaLobeP8)/(12.f*pi) - (5*cosThetaLobeP10)/(9.f*pi) + (31.f*thetaLobe*cosThetaLobe*sinThetaLobe)/(120.f*pi) + (thetaLobe*cosThetaLobeP3*sinThetaLobe)/(24.f*pi) + 19.f/320.f;
        
        if (thetaLobe > pi/2.f) {
            return rightQuarterSphereClipped;
        } else {
            return fullHemisphereClipped;
        }
    }
    
    void specularLobeTests() {
            std::ofstream specularLobeCoefficients;
            //        specularLobeCoefficients.open ("ADSRBFSpecularLobeCoefficients.csv");
            //        specularLobeCoefficients << "ggxAlpha,NdotV,vertDotV,vertDotN,vertDotR,integral" << std::endl;
            //        specularLobeCoefficients.open ("ADSRBFSpecularLobeCoefficientsIsotropic.csv");
            //        specularLobeCoefficients << "ggxAlpha,vertDotN,integral" << std::endl;
    
    
    
            // View direction, vertex direction, roughness. Normal is always at (0, 0, 1).
            // View direction is 2D (phi, theta). Vertex direction is 2D but fixed (phi = 0). Roughness is 1D.
            // For vertex direction we're interested in cos(theta). For view direction it's cos(theta) and cos(phi).
    
//            specularLobeCoefficients.open ("ADSRBFSpecularLobeCoefficientsMS.csv");
//            specularLobeCoefficients << "ggxAlpha,NdotV,vertexDotN,vertexDotR,basisInMirrorDir,integral" << std::endl;
//
//    //
//    //        {
//    //            for (u64 alphaIt = 1; alphaIt <= 20; alphaIt += 1) {
//    //                float sqrtAlpha = alphaIt / 20.0; // The GGX roughness parameter.
//    //                float alpha = sqrtAlpha * sqrtAlpha;
//    //
//    //                for (u64 thetaVert = 0; thetaVert <= 31; thetaVert += 1) {
//    //                    const float sinThetaVert = sin(float(thetaVert) * M_PI / 31.f);
//    //                    const float cosThetaVert = cos(float(thetaVert) * M_PI / 31.f);
//    //
//    //                    const vec3 vertex = vec3(0, sinThetaVert, cosThetaVert);
//    //
//    //                    for (u64 phiV = 0; phiV <= 31; phiV += 1) {
//    //                        const float sinPhiV = sin(float(phiV) * M_PI / 31.f);
//    //                        const float cosPhiV = cos(float(phiV) * M_PI / 31.f);
//    //
//    //                        for (u64 thetaV = 0; thetaV <= 31; thetaV += 1) {
//    //                            const float sinThetaV = sin(float(thetaV) * M_PI_2 / 31.f);
//    //                            const float cosThetaV = cos(float(thetaV) * M_PI_2 / 31.f);
//    //
//    //                            const vec3 V = vec3(sinThetaV * sinPhiV, sinThetaV * cosPhiV, cosThetaV);
//    //
//    //                            vec2 integral = vec2(0.0); // for f0 and f90MinusF0
//    //                            const u64 sampleCount = 2048;
//    //                            const float sampleScale = 1.f / float(sampleCount);
//    //                            for (uint sampleIt = 0u; sampleIt < sampleCount; sampleIt += 1u) {
//    //                                vec2 sampleUV = vec2(sampleHalton(sampleIt, 2), sampleHalton(sampleIt, 3));
//    //                                vec3 H = sampleGGXVNDF(V, alpha, alpha, sampleUV.x, sampleUV.y); // depends on viewDirTheta, viewDirPhi
//    //                                vec3 lightDirectionTangent = reflect(-V, H); // depends on viewDirTheta, viewDirPhi
//    //                                if (lightDirectionTangent.z < 0) { continue; }
//    //
//    //                                //Specular
//    //                                float Vis = SmithGGXMaskingShadowingG2OverG1Reflection(V, lightDirectionTangent, H, alpha); // depends on viewDirTheta, viewDirPhi
//    //                                float f0Weight = 1.f;
//    //                                float f90MinusF0Weight = pow(1.f - saturate(dot(V, H)), 5.f);  //native_powr(1.f - u, 5.f);
//    //
//    //                                vec2 brdf = vec2(f0Weight, f90MinusF0Weight) * Vis;
//    //
//    //                                // How much does the average reflected direction lie along the basis function?
//    //                                float basis = 0.0;
//    //                                {
//    //                                    float dotProduct = max(dot(lightDirectionTangent, vertex), 0.f);
//    //                                    float cos2 = dotProduct * dotProduct;
//    //                                    float cos4 = cos2 * cos2;
//    //                                    basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
//    //                                }
//    //
//    //                                integral+= brdf * basis * sampleScale;
//    //                            }
//    //
//    //                            specularLobeCoefficients << alpha << "," << cosThetaVert << "," << sinPhiV << "," << cosPhiV << "," << integral.x << "," << integral.y << std::endl;
//    //                        }
//    //                    }
//    //                }
//    //            }
//    //
//    //            specularLobeCoefficients.close();
//    //            exit(0);
//    //        }
//
//            const size_t lobeDirCount = 32;
//
//            vec3 lobeDirs[lobeDirCount] = {};
//            for (u64 lobeDirIt = 0; lobeDirIt < lobeDirCount; lobeDirIt += 1) {
//                const vec2 sample = vec2(sampleHalton(lobeDirIt + 1, 3), sampleHalton(lobeDirIt + 1, 2));
//                const vec3 vertex = sampleUniformSphere(sample.x, sample.y);
//                lobeDirs[lobeDirIt] = vertex;
//            }
//
//            for (u64 alphaIt = 1; alphaIt <= 0 /* 20 */; alphaIt += 1) {
//                float sqrtAlpha = alphaIt / 20.0; // The GGX roughness parameter.
//                float alpha = sqrtAlpha * sqrtAlpha;
//
//                const vec3 N = vec3(0, 0, 1);
//
//                Microsurface *microsurface = new MicrosurfaceDielectric(false, false, alpha, alpha);
//
//                //            MatrixXf weightMatrix = MatrixXf::Zero(512, 5);
//                //            VectorXf integralVector = VectorXf::Zero(512);
//
//
//                for (u64 viewDirIt = 1; viewDirIt <= 128; viewDirIt += 1) {
//                    const vec2 sample = vec2(sampleHalton(viewDirIt, 2), sampleHalton(viewDirIt, 3));
//                    const vec3 V = sampleUniformHemisphere(sample.x, sample.y);
//                    const float NdotV = V.z;
//
//                    vec3 mirrorReflectionDir = reflect(-V, N);
//
//                    double integrals[lobeDirCount] = { 0.0 };
//                    {
//                        const u64 sampleCount = 4096;
//                        const double sampleScale = 1.0 / double(sampleCount);
//
//                        for (u64 sampleIt = 1; sampleIt <= sampleCount; sampleIt += 1) {
//                            vec3 H = microsurface->sample(V);
//                            vec3 lightDirectionTangent = reflect(-V, H);
//
//                            for (size_t lobeDirIt = 0; lobeDirIt < lobeDirCount; lobeDirIt += 1) {
//                                // How much does the average reflected direction lie along the basis function?
//                                double basis = 0.0;
//                                {
//                                    double dotProduct = max(dot(lightDirectionTangent, lobeDirs[lobeDirIt]), 0.f);
//                                    double cos2 = dotProduct * dotProduct;
//                                    double cos4 = cos2 * cos2;
//                                    basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
//                                }
//
//                                integrals[lobeDirIt] += basis * sampleScale;
//                            }
//                        }
//                    }
//
//
//
//                    for (size_t lobeDirIt = 0; lobeDirIt < lobeDirCount; lobeDirIt += 1) {
//                        const vec3 vertex = lobeDirs[lobeDirIt];
//                        const float vertexDotV = dot(V, vertex);
//                        const float vertexDotN = vertex.z;
//
//                        float vertexDotR = dot(vertex, mirrorReflectionDir);
//                        float vertexDotRSq = max(vertexDotR, 0.f) * max(vertexDotR, 0.f);
//                        float basisInMirrorDir = 0.35 * vertexDotRSq + 0.25 * vertexDotRSq * vertexDotRSq;
//
//                        //                    specularLobeCoefficients << alpha << "," << NdotV << "," << vertexDotV << "," << vertexDotN << "," << integral << std::endl;
//                        //                    specularLobeCoefficients << alpha << "," << vertexDotN << "," << integral << std::endl;
//
//                        std::cout << alpha << "," << NdotV << "," << vertexDotN << "," << vertexDotR << "," << basisInMirrorDir << "," << integrals[0] << std::endl;
//                        specularLobeCoefficients << alpha << "," << NdotV << "," << vertexDotN << "," << vertexDotR << "," << basisInMirrorDir << "," << integrals[lobeDirIt] << std::endl;
//
//                        //                    weightMatrix(lobeDirIt, 0) = 1.0;
//                        //                    weightMatrix(lobeDirIt, 1) = vertexDotN;
//                        //                    weightMatrix(lobeDirIt, 2) = vertexDotN * vertexDotN;
//                        //                    weightMatrix(lobeDirIt, 3) = vertexDotN * vertexDotN * vertexDotN;
//                        //                    weightMatrix(lobeDirIt, 4) = vertexDotN * vertexDotN * vertexDotN * vertexDotN;
//                        //
//                        //                    integralVector[lobeDirIt] = (float)integral;
//                    }
//                }
//
//                delete microsurface;
//            }
//
//            specularLobeCoefficients.close();
    
            {
    
                const size_t imageSize = 320;
                Image ambientDiceLobeSpecularFull(imageSize * 16, imageSize * 20);
    
                const size_t vertexPositionCount = 16;
                vec3 vertexPositions[vertexPositionCount];
                for (size_t vertexPosIt = 0; vertexPosIt < vertexPositionCount; vertexPosIt += 1) {
                    const float cosTheta = 1.f - 2.f * vertexPosIt / float(vertexPositionCount);
                    vertexPositions[vertexPosIt] = vec3(0, sqrt(1.f - cosTheta * cosTheta), cosTheta);
                }
    
                const vec3 normal = vec3(0, 0, 1);
    
                for (u64 alphaIt = 1; alphaIt <= 20; alphaIt += 1) {
                    float sqrtAlpha = alphaIt / 20.0; // The GGX roughness parameter.
                    float alpha = sqrtAlpha * sqrtAlpha;
    
                    Microsurface *microsurface = new MicrosurfaceConductor(false, false, alpha, alpha);
    
    
                    Image ambientDiceLobeSpecular[vertexPositionCount];
                    for (size_t vertexPosIt = 0; vertexPosIt < vertexPositionCount; vertexPosIt += 1) {
                        ambientDiceLobeSpecular[vertexPosIt] = Image(imageSize, imageSize);
                    }
    
                    parallelFor(0u, uint32(imageSize * imageSize), [&](u32 i)
                                {
                                    u32 y = i / imageSize;
                                    u32 x = i % imageSize;
                                    vec2 coord = vec2(2.0) * vec2(x, y) / vec2(imageSize) - vec2(1.0);
    
                                    if (dot(coord, coord) > 1.0) {
                                        for (size_t vertexPosIt = 0; vertexPosIt < vertexPositionCount; vertexPosIt += 1) {
                                            ambientDiceLobeSpecular[vertexPosIt].at(x, y) = vec4(0.0);
                                        }
                                        return;
                                    }
    
                                    vec3 V = vec3(coord, sqrt(1.0 - dot(coord, coord)));
    
    //                                vec2 coord = vec2(x, y) / vec2(imageSize);
    //                                float cosThetaV = coord.x;
    //                                float cosPhiV = 1.f - 2.f * coord.y;
    //                                float sinThetaV = sqrt(1.f - cosThetaV * cosThetaV);
    //                                float sinPhiV = sqrt(1.f - cosPhiV * cosPhiV);
    //
    //                                vec3 V = vec3(sinPhiV * sinThetaV, cosPhiV * sinThetaV, cosThetaV);
    
                                    const uint sampleCount = 4096u;
                                    const float sampleScale = 1.0 / float(sampleCount);
    
                                    vec2 integrals[vertexPositionCount] = { vec2(0.0) }; // for f0 and f90MinusF0
    
                                    vec2 lutValue = vec2(0.0); // for f0 and f90MinusF0
                                    for (uint sampleIt = 0u; sampleIt < sampleCount; sampleIt += 1u) {
    //                                    vec3 lightDirectionTangent = microsurface->sample(V);
    //                                    vec3 H = normalize(V + lightDirectionTangent);
    //
    //                                    float f0Weight = 1.f;
    //                                    float f90MinusF0Weight = pow(1.f - saturate(dot(V, H)), 5.f);  //native_powr(1.f - u, 5.f);
    //
    //                                    vec2 brdf = vec2(f0Weight, f90MinusF0Weight);
    //                                    assert(lightDirectionTangent.z >= 0.f);
    
                                        vec2 sampleUV = vec2(sampleHalton(sampleIt + 1, 2), sampleHalton(sampleIt + 1, 3));
                                        vec3 H = sampleGGXVNDF(V, alpha, alpha, sampleUV.x, sampleUV.y); // depends on viewDirTheta, viewDirPhi
                                        vec3 lightDirectionTangent = reflect(-V, H); // depends on viewDirTheta, viewDirPhi
                                        if (lightDirectionTangent.z < 0) { continue; }
    
                                        //Specular
                                        float Vis = SmithGGXMaskingShadowingG2OverG1Reflection(V, lightDirectionTangent, H, alpha); // depends on viewDirTheta, viewDirPhi
                                        float f0Weight = 1.f;
                                        float f90MinusF0Weight = pow(1.f - saturate(dot(V, H)), 5.f);
    
                                        vec2 brdf = vec2(f0Weight, f90MinusF0Weight) * Vis;
    
                                        for (size_t vertexPosIt = 0; vertexPosIt < vertexPositionCount; vertexPosIt += 1) {
                                            // How much does the average reflected direction lie along the basis function?
                                            float basis = 0.0;
                                            {
                                                float dotProduct = max(dot(lightDirectionTangent, vertexPositions[vertexPosIt]), 0.f);
                                                float cos2 = dotProduct * dotProduct;
                                                float cos4 = cos2 * cos2;
                                                basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
                                            }
    
                                            integrals[vertexPosIt] += brdf * basis * sampleScale;
                                        }
                                        lutValue += brdf * sampleScale; // * lightDirectionTangent.z;
                                    }
    
                                    // integral /= lutValue;
    
                                    const float parameters[10] = { -0.03480017115306019, 1.5767277269939315, 3.2915521747760006, -8.886052306193424, 5.289174934167271, 0.658318188157326, -0.9258960547724002, 2.9786527829025813, -2.0077225608393703, 0.2642150798240006 };
                                    
                                    for (size_t vertexPosIt = 0; vertexPosIt < vertexPositionCount; vertexPosIt += 1) {
    //                                    integrals[vertexPosIt] = estimateSRBFBasisWeightGGXCustomFit(alpha, vertexPositions[vertexPosIt], normal, V);
                                        vec3 R = reflect(-V, vec3(0, 0, 1));
                                        float dotProduct = dot(vertexPositions[vertexPosIt], R);
                                        float cos2 = square(max(dotProduct, 0.f));
                                        float cos4 = cos2 * cos2;
                                        float basisInMirrorDir = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
                                        
                                        float focusLerp = parameters[5] + parameters[6] * alpha + parameters[7] * alpha * alpha + parameters[8] * alpha * alpha * alpha + parameters[9] * alpha * alpha * alpha * alpha;
                                        float diffuseParam = mix(dotProduct, vertexPositions[vertexPosIt].z, saturate(focusLerp));
                                        float diffuse = 0.06 + 0.129 * diffuseParam + 0.0697 * diffuseParam * diffuseParam;
                                        
                                        float alphaLerp = parameters[0] + parameters[1] * alpha + parameters[2] * alpha * alpha + parameters[3] * alpha * alpha * alpha + parameters[4] * alpha * alpha * alpha * alpha;
                                        
                                        float value = mix(basisInMirrorDir, diffuse, saturate(alphaLerp));
    
                                        ambientDiceLobeSpecular[vertexPosIt].at(x, y) = vec4(value * lutValue.x, value * lutValue.y, 0, 1.0);
//                                        ambientDiceLobeSpecular[vertexPosIt].at(x, y) =  vec4(integrals[vertexPosIt].x, integrals[vertexPosIt].y, 0, 1.0);
                                    }
                                });
    
    
                    for (size_t vertexPosIt = 0; vertexPosIt < vertexPositionCount; vertexPosIt += 1) {
                        const float theta = vertexPosIt / float(vertexPositionCount) * M_PI;
                        std::string fileName = "AmbientDiceSSSpecular-alpha=" + std::to_string(alpha) + "-lobeTheta=" + std::to_string(theta) + ".hdr";
//                        ambientDiceLobeSpecular[vertexPosIt].writeHdr(fileName.c_str());
    
                        ambientDiceLobeSpecularFull.paste(ambientDiceLobeSpecular[vertexPosIt], ivec2(imageSize * vertexPosIt, imageSize * (alphaIt - 1)));
                    }
    
                    delete microsurface;
                }
    
                std::string fileName = "AmbientDiceSSSpecularFullApproxSimple.hdr";
                ambientDiceLobeSpecularFull.writeHdr(fileName.c_str());
            }

    }
    
    void ExperimentAmbientDice::run(SharedData& data)
    {
        
        using namespace Eigen;
        
        //        MatrixXd bezierGram = AmbientDice::computeGramMatrixBezier();
        
        //        std::cout << "const float ambientDiceGramBezier[36][36] = {\n";
        //        for (u64 i = 0; i < 36; i += 1) {
        //            std::cout << "    { ";
        //
        //            for (u64 j = 0; j < 36; j += 1) {
        //                std::cout << bezierGram(i, j) << ", ";
        //            }
        //            std::cout << "},\n";
        //        }
        //        std::cout << "}\n";
        
        
        //        MatrixXd srbfGram = AmbientDice::computeGramMatrixSRBF();
        //        MatrixXd srbfGramInverse = pseudoInverse(srbfGram);
        //
        //        std::cout << "const float ambientDiceGramSRBFInverse[12][12] = {\n";
        //        for (u64 i = 0; i < 12; i += 1) {
        //            std::cout << "    { ";
        //
        //            for (u64 j = 0; j < 12; j += 1) {
        //                std::cout << srbfGramInverse(i, j) << ", ";
        //            }
        //            std::cout << "},\n";
        //        }
        //        std::cout << "}\n";
        
        
        //        std::cout << "alpha";
        //        for (u64 i = 0; i < 36; i += 1) {
        //            for (u64 j = i; j < 36; j += 1) {
        //                std::cout << ",coeff" << i << "-" << j;
        //            }
        //        }
        //        std::cout << std::endl;
        //
        //        MatrixXd inverseGram = pseudoInverse(AmbientDice::computeGramMatrixBezier());
        //        MatrixXd diffuseMatrix = inverseGram * computeCosineGramMatrixBezier();
        //
        //        for (u64 i = 1; i <= 20; i += 1) {
        //            double sqrtAlpha = double(i) / 20.0;
        //            double alpha = sqrtAlpha * sqrtAlpha;
        //
        //            std::cout << alpha;
        //
        //            MatrixXd resultMatrix = inverseGram * computeGGXGramMatrixBezier(alpha, false);
        //
        //            for (u64 i = 0; i < 36; i += 1) {
        //                for (u64 j = i; j < 36; j += 1) {
        //                    double val = resultMatrix(i, j);
        //
        //                    std::cout << "," << val;
        //                }
        //            }
        //
        //            std::cout << std::endl;
        //        }
        
        m_radianceImage = Image(data.m_outputSize);
        m_specularImage = Image(data.m_outputSize);
        m_irradianceImage = Image(data.m_outputSize);
        
        
        //        std::cout << "theta,costheta,integral" << std::endl;
        //
        //        for (u64 angleIt = 0; angleIt < 600.0; angleIt += 1) {
        //            float theta = angleIt / 600.0f * M_PI; // The angle between the vertex and the sample direction.
        //
        //            const vec3 lobeDirection = vec3(0, 0, 1);
        //            vec3 normal = vec3(sin(theta), 0, cos(theta));
        //
        //            const u64 sampleCount = 2048;
        //            const double sampleScale = 2 * M_PI / double(sampleCount);
        //
        //            //                  double integral = 0.0;
        //            //                  for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
        //            //                      vec3 sDirection = sampleUniformSphere(sampleHammersley(sampleIt, sampleCount));
        //            //
        //            //                      double dotProduct = max(dot(sDirection, vertexDir), 0.0f);
        //            //                      double cos2 = dotProduct * dotProduct;
        //            //                      double cos4 = cos2 * cos2;
        //            //
        //            //                      double basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
        //            //
        //            //                      double brdf = max(dot(sDirection, direction), 0.f) * M_1_PI;
        //            //
        //            //                      integral += brdf * basis * sampleScale;
        //            //                  }
        //            //
        //            double integral = 0.0;
        //            for (u64 sampleIt = 0; sampleIt < sampleCount; sampleIt += 1) {
        //                vec3 lightDirection = sampleUniformHemisphere(sampleHalton(sampleIt + 1, 2), sampleHalton(sampleIt + 1, 3));
        //
        //                double dotProduct = lightDirection.z; // == dot(lobeDirection, lightDirection) since the vertex is (0, 0, 1). Strictly positive since we're sampling the hemisphere.
        //                double cos2 = dotProduct * dotProduct;
        //                double cos4 = cos2 * cos2;
        //
        //                double basis = 0.7f * (0.5f * cos2) + 0.3f * (5.f / 6.f * cos4);
        //
        //                double brdf = max(dot(lightDirection, normal), 0.f) * M_1_PI;
        //
        //                integral += brdf * basis * sampleScale;
        //            }
        //
        //            std::cout << theta << "," << cos(theta) << "," << integral << std::endl;
        //        }
        
        //
        ////            VectorXf polynomialCoeffs = weightMatrix.colPivHouseholderQr().solve(integralVector);
        ////            std::cout << alpha << "," << polynomialCoeffs[0] << "," << polynomialCoeffs[1] << "," << polynomialCoeffs[2] << "," << polynomialCoeffs[3] << "," << polynomialCoeffs[4] << std::endl;
        //
        //
        //
        //        specularLobeCoefficients.close();
        
        
        if (m_diceType == AmbientDiceTypeBezier) {
            AmbientDice ambientDiceRadiance = solveAmbientDiceLeastSquaresBezier(data.m_directionImage, m_input->m_radianceImage);
            
            //            AmbientDice ambientDiceSpecular = solveAmbientDiceLeastSquares(data.m_directionImage, m_input->m_specularImage);
            AmbientDice ambientDiceSpecular = ambientDiceConvertRadianceToSpecularBezier(ambientDiceRadiance);
            
            //            AmbientDice ambientDiceIrradiance = solveAmbientDiceLeastSquares(data.m_directionImage, m_input->m_irradianceImage);
            AmbientDice ambientDiceIrradiance = ambientDiceConvertRadianceToIrradianceBezier(ambientDiceRadiance);
            
            data.m_directionImage.forPixels2D([&](const vec3& direction, ivec2 pixelPos)
                                              {
                                                  if (upperHemisphereOnly && direction.z < 0) {
                                                      return;
                                                  }
                                                  
                                                  vec3 sampleRadiance = ambientDiceRadiance.evaluateBezier(direction);
                                                  m_radianceImage.at(pixelPos) = vec4(sampleRadiance, 1.0f);
                                                  
                                                  vec3 sampleIrradiance = ambientDiceIrradiance.evaluateBezier(direction);
                                                  m_irradianceImage.at(pixelPos) = vec4(sampleIrradiance, 1.0f);
                                                  
                                                  vec3 sampleSpecular = ambientDiceSpecular.evaluateBezier(direction);
                                                  m_specularImage.at(pixelPos) = vec4(sampleSpecular, 1.0f);
                                              });
        } else if (m_diceType == AmbientDiceTypeBezierYCoCg) {
            AmbientDice ambientDiceRadiance = solveAmbientDiceLeastSquaresBezierYCoCg(data.m_directionImage, m_input->m_radianceImage);
            
            AmbientDice ambientDiceSpecular = solveAmbientDiceLeastSquaresBezierYCoCg(data.m_directionImage, m_input->m_specularImage);
            //            AmbientDice ambientDiceSpecular = ambientDiceConvertRadianceToSpecularBezier(ambientDiceRadiance);
            
            AmbientDice ambientDiceIrradiance = solveAmbientDiceLeastSquaresBezierYCoCg(data.m_directionImage, m_input->m_irradianceImage);
            //            AmbientDice ambientDiceIrradiance = ambientDiceConvertRadianceToIrradianceBezier(ambientDiceRadiance);
            
            data.m_directionImage.forPixels2D([&](const vec3& direction, ivec2 pixelPos)
                                              {
                                                  if (upperHemisphereOnly && direction.z < 0) {
                                                      return;
                                                  }
                                                  vec3 sampleRadiance = ambientDiceRadiance.evaluateBezierYCoCg(direction);
                                                  m_radianceImage.at(pixelPos) = vec4(sampleRadiance, 1.0f);
                                                  
                                                  vec3 sampleIrradiance = ambientDiceIrradiance.evaluateBezierYCoCg(direction);
                                                  m_irradianceImage.at(pixelPos) = vec4(sampleIrradiance, 1.0f);
                                                  
                                                  vec3 sampleSpecular = ambientDiceSpecular.evaluateBezierYCoCg(direction);
                                                  m_specularImage.at(pixelPos) = vec4(sampleSpecular, 1.0f);
                                              });
            
        } else /* if (m_diceType == AmbientDiceTypeSRBF) */ {
            
            AmbientDice ambientDiceRadiance = solveAmbientDiceLeastSquaresSRBF(data.m_directionImage, m_input->m_radianceImage);
            
//            for (u64 i = 0; i <= 10; i += 1) {
//                float alphaSqrt = (float)i / 10.f + 1e-3f;
//                float alpha = alphaSqrt * alphaSqrt;
//
//                const float f0 = 0.8f;
//
//                const vec3 N = vec3(0, 0, 1);
//
//                Image specularImageSRBFGT = Image(data.m_outputSize);
//                Image specularImageSRBFApprox = Image(data.m_outputSize);
//
//                data.m_directionImage.forPixels2D([&](const vec3& V, ivec2 pixelPos)
//                                                  {
//                                                      vec3 total = vec3(0.f);
//                                                      vec3 totalApprox = vec3(0.f);
//                                                      for (size_t i = 0; i < 9; i += 1) {
//                                                          const vec3 vertexDir = AmbientDice::srbfHemisphereVertexPositions[i];
//                                                          vec2 integral = evaluateSRBFBasisWeightGGX(alpha, vertexDir, N, V);
//                                                          vec2 approxIntegral = estimateSRBFBasisWeightGGXCustomFit(alpha, vertexDir, N, V);
//
//                                                          total += (integral.x * f0 + integral.y) * ambientDiceRadiance.vertices[i].value;
//                                                          totalApprox += (approxIntegral.x * f0 + approxIntegral.y) * ambientDiceRadiance.vertices[i].value;
//                                                      }
//
//                                                      specularImageSRBFGT.at(pixelPos) = vec4(total, 1.0f);
//                                                      specularImageSRBFApprox.at(pixelPos) = vec4(totalApprox, 1.0f);
//                                                  });
//
//                {
//                    std::string hdrFileName = "specularImageSRBF-Alpha" + std::to_string(alpha) + "-GT.hdr";
//                    std::string pngFileName = "specularImageSRBF-Alpha" + std::to_string(alpha) + "-GT.png";
//                    specularImageSRBFGT.writeHdr(hdrFileName.c_str());
//                    specularImageSRBFGT.writePng(pngFileName.c_str());
//                }
//
//                {
//                    std::string hdrFileName = "specularImageSRBF-Alpha" + std::to_string(alpha) + "-Approx.hdr";
//                    std::string pngFileName = "specularImageSRBF-Alpha" + std::to_string(alpha) + "-Approx.png";
//                    specularImageSRBFApprox.writeHdr(hdrFileName.c_str());
//                    specularImageSRBFApprox.writePng(pngFileName.c_str());
//                }
//            }
            //        exit(0);
            
            std::cout << "Ambient Dice Inverse Gram:" << std::endl;
            
            std::cout << pseudoInverse(AmbientDice::computeGramMatrixSRBF()) << std::endl;
            
            std::cout << std::endl;
            
            AmbientDice ambientDiceIrradiance = solveAmbientDiceLeastSquaresSRBF(data.m_directionImage, m_input->m_irradianceImage);
//            AmbientDice ambientDiceIrradiance = ambientDiceConvertRadianceToIrradianceSRBF(ambientDiceRadiance);
            
            if (false) {
                std::cout << "alpha,lerpFactor" << std::endl;
                
                MatrixXd inverseGram = pseudoInverse(AmbientDice::computeGramMatrixSRBF(hemisphericalIntegral));
                
                for (u64 i = 1; i <= 40; i += 1) {
                    double sqrtAlpha = double(i) / 40.0;
                    double alpha = sqrtAlpha * sqrtAlpha;
                    
                    MatrixXd resultMatrix = inverseGram * computeGGXGramMatrixSRBF(alpha, false);
                    
                    AmbientDice trueSpecular = { };
                    
                    for (u64 vert = 0; vert < vertexCount; vert += 1) {
                        for (u64 otherVert = 0; otherVert < vertexCount; otherVert += 1) {
                            trueSpecular.vertices[vert].value += ambientDiceRadiance.vertices[otherVert].value * (float)resultMatrix(vert, otherVert);
                        }
                    }
                    
                    double bestLerpFactor = 0.0;
                    double bestError = DBL_MAX;
                    for (u64 i = 0; i <= 40; i += 1) {
                        double lerpFactor = double(i) / 40.0;
                        
                        double error = 0.0;
                        for (u64 vert = 0; vert < vertexCount; vert += 1) {
                            vec3 delta = mix(ambientDiceRadiance.vertices[vert].value, ambientDiceIrradiance.vertices[vert].value, lerpFactor) - trueSpecular.vertices[vert].value;
                            error += dot(delta * delta, vec3(0.333333));
                        }
                        if (error < bestError) {
                            bestError = error;
                            bestLerpFactor = lerpFactor;
                        }
                    }
                    
                    std::cout << alpha << "," << bestLerpFactor << std::endl;
                }
            }
            
            AmbientDice ambientDiceSpecular = solveAmbientDiceLeastSquaresSRBF(data.m_directionImage, m_input->m_specularImage);
            //            AmbientDice ambientDiceSpecular = ambientDiceConvertRadianceToSpecularSRBF(ambientDiceRadiance);
            
            
            data.m_directionImage.forPixels2D([&](const vec3& direction, ivec2 pixelPos)
                                              {
                                                  if (upperHemisphereOnly && direction.z < 0) {
                                                      return;
                                                  }
                                                  
                                                  vec3 sampleRadiance = ambientDiceRadiance.evaluateSRBF(direction);
                                                  m_radianceImage.at(pixelPos) = vec4(sampleRadiance, 1.0f);
                                                  
                                                  vec3 sampleIrradiance = vec3(0.f); // ambientDiceIrradiance.evaluateSRBF(direction);
                                                  if (upperHemisphereOnly && useHemisphereVertexPositions) {
                                                      for (u64 vert = 0; vert < 9; vert += 1) {
                                                          // estimateSRBFBasisWeightGGXCustomFit
                                                          float dotProduct = dot(AmbientDice::srbfHemisphereVertexPositions[vert], direction);
                                                          float w0 = 0.06f + 0.129f * dotProduct + 0.0697 * dotProduct * dotProduct; // 2 * vert
                                                          
                                                          sampleIrradiance += w0 * ambientDiceRadiance.vertices[vert].value;
                                                      }
                                                  } else {
                                                        for (u64 vert = 0; vert < 6; vert += 1) {
                                                  
                                                            float dotProduct = dot(AmbientDice::srbfNormalisedVertexPositions[vert], direction);
                                                  
                                                            float w0 = 0.06f + 0.129f * dotProduct + 0.0697 * dotProduct * dotProduct; // 2 * vert
                                                            float w1 = 0.06f + 0.129f * -dotProduct + 0.0697 * dotProduct * dotProduct; // 2 * vert + 1
                                                  
                                                            sampleIrradiance += w0 * ambientDiceRadiance.vertices[2 * vert].value;
                                                            sampleIrradiance += w1 * ambientDiceRadiance.vertices[2 * vert + 1].value;
                                                        }
                                                  }
                                                  
                                                  m_irradianceImage.at(pixelPos) = vec4(sampleIrradiance, 1.0f);
                                                  
                                                  vec3 sampleSpecular = vec3(0.f); // ambientDiceSpecular.evaluateSRBF(direction);
                                                  if (direction.z < 0 && upperHemisphereOnly) {
                                                      sampleSpecular = vec3(0);
                                                  }
                                                  
                                                vec3 V = upperHemisphereOnly ? vec3(-direction.x, -direction.y, direction.z) : direction;

                                                if (upperHemisphereOnly && useHemisphereVertexPositions) {
                                                    for (u64 vert = 0; vert < 9; vert += 1) {
                                                        // estimateSRBFBasisWeightGGXCustomFit
                                                        vec2 w0 = estimateSRBFBasisWeightGGXCustomFit(ggxAlpha, AmbientDice::srbfHemisphereVertexPositions[vert], vec3(0, 0, 1), V);

                                                        sampleSpecular += (w0.x * specularF0 + w0.y) * ambientDiceRadiance.vertices[vert].value;
                                                    }
                                                } else {
                                                    for (u64 vert = 0; vert < 6; vert += 1) {
                                                        // estimateSRBFBasisWeightGGXCustomFit
                                                        vec2 w0 = estimateSRBFBasisWeightGGXCustomFit(ggxAlpha, AmbientDice::srbfNormalisedVertexPositions[vert], upperHemisphereOnly ? vec3(0, 0, 1) : direction, V);
                                                        vec2 w1 = estimateSRBFBasisWeightGGXCustomFit(ggxAlpha, -AmbientDice::srbfNormalisedVertexPositions[vert], upperHemisphereOnly ? vec3(0, 0, 1) : direction, V);

                                                        sampleSpecular += (w0.x * specularF0 + w0.y) * ambientDiceRadiance.vertices[2 * vert].value;
                                                        sampleSpecular += (w1.x * specularF0 + w1.y) * ambientDiceRadiance.vertices[2 * vert + 1].value;
                                                    }
                                                }
                                                  
                                                  
                                                  m_specularImage.at(pixelPos) = vec4(sampleSpecular, 1.0f);
                                              });
        }
    }
}
